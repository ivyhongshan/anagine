"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.textAggregation = exports.numericHistogramWithFixedRangeStep = exports.numericHistogramWithFixedBinCount = exports.numericGlobalStats = exports.numericAggregation = exports.appendAdditionalRangeQuery = void 0;var _graphql = require("graphql");
var _filter = _interopRequireDefault(require("./filter"));
var _const = require("./const");





var _config = _interopRequireDefault(require("../config"));function _interopRequireDefault(e) {return e && e.__esModule ? e : { default: e };}

const PAGE_SIZE = 10000;

const updateAggObjectForTermsFields = (termsFields, aggsObj) => {
  const newAggsObj = { ...aggsObj };
  termsFields.forEach((element) => {
    const variableName = `${element}Terms`;
    newAggsObj[variableName] = {
      terms: {
        field: element,
        size: PAGE_SIZE
      }
    };
  });
  return newAggsObj;
};

const updateAggObjectForMissingFields = (missingFields, aggsObj) => {
  const newAggsObj = { ...aggsObj };
  missingFields.forEach((element) => {
    const variableName = `${element}Missing`;
    newAggsObj[variableName] = {
      missing: {
        field: element
      }
    };
  });
  return newAggsObj;
};

const processResultsForNestedAgg = (nestedAggFields, item, resultObj) => {
  let missingFieldResult;
  if (nestedAggFields && nestedAggFields.missingFields) {
    missingFieldResult = [];
    nestedAggFields.missingFields.forEach((element) => {
      const variableName = `${element}Missing`;
      missingFieldResult.push({
        field: element,
        count: item[variableName].doc_count
      });
    });
  }

  let termsFieldResult;
  if (nestedAggFields && nestedAggFields.termsFields) {
    termsFieldResult = [];
    nestedAggFields.termsFields.forEach((element) => {
      const tempResult = {};
      tempResult.field = element;
      tempResult.terms = [];
      tempResult.count = 0;
      const variableName = `${element}Terms`;
      if (item[variableName].buckets && item[variableName].buckets.length > 0) {
        item[variableName].buckets.forEach((itemElement) => {
          tempResult.terms.push({
            key: itemElement.key,
            count: itemElement.doc_count
          });
          tempResult.count += itemElement.doc_count;
        });
      } else {
        tempResult.terms.push({
          key: null,
          count: 0
        });
      }
      termsFieldResult.push(tempResult);
    });
  }

  const newResultObj = {
    ...resultObj,
    ...(missingFieldResult && { missingFields: missingFieldResult }),
    ...(termsFieldResult && { termsFields: termsFieldResult })
  };
  return newResultObj;
};

/**
 * This function appends extra range limitation onto a query body "oldQuery"
 * export for test
 * @param {string} field - which field to append range limitation to
 * @param {object} oldQuery  - the old query body to append
 * @param {number} rangeStart - the range start
 * @param {number} rangeEnd - the range end
 */
const appendAdditionalRangeQuery = (field, oldQuery, rangeStart, rangeEnd) => {
  const appendFilter = [];
  if (typeof rangeStart !== 'undefined') {
    appendFilter.push({
      range: {
        [field]: { gte: rangeStart }
      }
    });
  }
  if (typeof rangeEnd !== 'undefined') {
    appendFilter.push({
      range: {
        [field]: { lt: rangeEnd }
      }
    });
  }
  if (appendFilter.length > 0) {
    const newQuery = {
      bool: {
        must: oldQuery ? [
        oldQuery,
        [...appendFilter]] :
        [...appendFilter]
      }
    };
    return newQuery;
  }
  return oldQuery;
};

/**
 * get global stats for a field
 * Export for test
 * @param {object} param0 - some ES related arguments: esInstance, esIndex, and esType
 * @param {object} param1 - some graphql related arguments
 * @param {object} param1.filter - filter (if any) to apply on aggregation
 * @param {object} param1.field - field to aggregate. Required
 * @param {object} param1.rangeStart - start value of the histogram, if empty, default to minimum
 * @param {object} param1.rangeEnd - end value of the histogram, if empty, default to maximum
 * @param {object} param1.rangeStep - histogram width. Required.
 * @param {object} param1.filterSelf - only valid if to avoid filtering the same aggregation field
 * @param {object} param1.defaultAuthFilter - once param1.filter is empty,
 *                                            use this auth related filter instead
 * @param {object} param1.nestedAggFields - fields for sub-aggregations
 *                                          (terms and/or missing aggregation)
 * @param {object} param1.nestedPath - path info used by nested aggregation
 * @returns {min, max, sum, count, avg, key}
 */exports.appendAdditionalRangeQuery = appendAdditionalRangeQuery;
const numericGlobalStats = async (
{
  esInstance,
  esIndex,
  esType
},
{
  filter,
  field,
  rangeStart,
  rangeEnd,
  filterSelf,
  defaultAuthFilter,
  nestedAggFields,
  nestedPath
}) =>
{
  const queryBody = { size: 0 };
  if (!!filter || !!defaultAuthFilter) {
    queryBody.query = (0, _filter.default)(
      esInstance,
      esIndex,
      filter,
      field,
      filterSelf,
      defaultAuthFilter
    );
  }
  queryBody.query = appendAdditionalRangeQuery(field, queryBody.query, rangeStart, rangeEnd);
  let aggsObj = {
    [_const.AGGS_GLOBAL_STATS_NAME]: {
      stats: {
        field: nestedPath ? `${nestedPath}.${field}` : `${field}`
      }
    }
  };
  if (nestedAggFields && nestedAggFields.termsFields) {
    aggsObj = updateAggObjectForTermsFields(nestedAggFields.termsFields, aggsObj);
  }
  if (nestedAggFields && nestedAggFields.missingFields) {
    aggsObj = updateAggObjectForMissingFields(nestedAggFields.missingFields, aggsObj);
  }
  if (nestedPath) {
    queryBody.aggs = {
      [_const.AGGS_NESTED_QUERY_NAME]: {
        nested: {
          path: nestedPath
        },
        aggs: {
          ...aggsObj
        }
      }
    };
  } else {
    queryBody.aggs = aggsObj;
  }

  const result = await esInstance.query(esIndex, esType, queryBody);
  let resultStats = nestedPath ?
  result.aggregations[_const.AGGS_NESTED_QUERY_NAME][_const.AGGS_GLOBAL_STATS_NAME] :
  result.aggregations[_const.AGGS_GLOBAL_STATS_NAME];
  const range = [
  typeof rangeStart === 'undefined' ? resultStats.min : rangeStart,
  typeof rangeEnd === 'undefined' ? resultStats.max : rangeEnd];

  resultStats = {
    key: range,
    ...resultStats
  };
  resultStats = processResultsForNestedAgg(nestedAggFields, result.aggregations, resultStats);
  return resultStats;
};

/**
 * This function does aggregation for numeric field, and returns histogram with given width.
 * Export for test
 * @param {object} param0 - some ES related arguments: esInstance, esIndex, and esType
 * @param {object} param1 - some graphql related arguments
 * @param {object} param1.filter - filter (if any) to apply on aggregation
 * @param {object} param1.field - field to aggregate. Required
 * @param {object} param1.rangeStart - start value of the histogram, if empty, default to minimum
 * @param {object} param1.rangeEnd - end value of the histogram, if empty, default to maximum
 * @param {object} param1.rangeStep - histogram width. Required.
 * @param {object} param1.filterSelf - only valid if to avoid filtering the same aggregation field
 * @param {object} param1.defaultAuthFilter - once param1.filter is empty,
 *                                            use this auth related filter instead
 * @param {object} param1.nestedAggFields - fields for sub-aggregations
 *                                          (terms and/or missing aggregation)
 * @param {object} param1.nestedPath - path info used by nested aggregation
 */exports.numericGlobalStats = numericGlobalStats;
const numericHistogramWithFixedRangeStep = async (
{
  esInstance,
  esIndex,
  esType
},
{
  filter,
  field,
  rangeStart,
  rangeEnd,
  rangeStep,
  filterSelf,
  defaultAuthFilter,
  nestedAggFields,
  nestedPath
}) =>
{
  const queryBody = { size: 0 };
  if (!!filter || !!defaultAuthFilter) {
    queryBody.query = (0, _filter.default)(
      esInstance,
      esIndex,
      filter,
      field,
      filterSelf,
      defaultAuthFilter,
      nestedAggFields
    );
  }
  queryBody.query = appendAdditionalRangeQuery(field, queryBody.query, rangeStart, rangeEnd);
  const aggsObj = {
    [_const.AGGS_GLOBAL_STATS_NAME]: {
      stats: {
        field: nestedPath ? `${nestedPath}.${field}` : `${field}`
      }
    }
  };
  aggsObj[_const.AGGS_QUERY_NAME] = {
    histogram: {
      field: nestedPath ? `${nestedPath}.${field}` : `${field}`,
      interval: rangeStep
    },
    aggs: {
      [_const.AGGS_ITEM_STATS_NAME]: {
        stats: {
          field: nestedPath ? `${nestedPath}.${field}` : `${field}`
        }
      }
    }
  };
  if (typeof rangeStart !== 'undefined') {
    let offset = rangeStart;
    while (offset - rangeStep > 0) {
      offset -= rangeStep;
    }
    aggsObj[_const.AGGS_QUERY_NAME].histogram.offset = offset;
  }
  if (nestedAggFields && nestedAggFields.termsFields) {
    aggsObj[_const.AGGS_QUERY_NAME].aggs = updateAggObjectForTermsFields(
      nestedAggFields.termsFields,
      aggsObj[_const.AGGS_QUERY_NAME].aggs
    );
  }
  if (nestedAggFields && nestedAggFields.missingFields) {
    aggsObj[_const.AGGS_QUERY_NAME].aggs = updateAggObjectForMissingFields(
      nestedAggFields.missingFields,
      aggsObj[_const.AGGS_QUERY_NAME].aggs
    );
  }

  if (nestedPath) {
    queryBody.aggs = {
      [_const.AGGS_NESTED_QUERY_NAME]: {
        nested: {
          path: nestedPath
        },
        aggs: {
          ...aggsObj
        }
      }
    };
  } else {
    queryBody.aggs = aggsObj;
  }

  const result = await esInstance.query(esIndex, esType, queryBody);
  const finalResults = [];
  let resultObj;
  const resultBuckets = nestedPath ?
  result.aggregations[_const.AGGS_NESTED_QUERY_NAME][_const.AGGS_QUERY_NAME].buckets :
  result.aggregations[_const.AGGS_QUERY_NAME].buckets;
  resultBuckets.forEach((item) => {
    resultObj = processResultsForNestedAgg(nestedAggFields, item, resultObj);
    finalResults.push({
      key: [item.key, item.key + rangeStep],
      ...item[_const.AGGS_ITEM_STATS_NAME],
      ...resultObj
    });
  });
  return finalResults;
};

/**
 * This function does aggregation for numeric field, and returns histogram with fixed bin count.
 * Export for test
 * @param {object} param0 - some ES related arguments: esInstance, esIndex, and esType
 * @param {object} param1 - some graphql related arguments
 * @param {object} param1.filter - filter (if any) to apply on aggregation
 * @param {object} param1.field - field to aggregate. Required
 * @param {object} param1.rangeStart - start value of the histogram, if empty, default to minimum
 * @param {object} param1.rangeEnd - end value of the histogram, if empty, default to maximum
 * @param {object} param1.binCount - histogram bin count. Required.
 * @param {object} param1.filterSelf - only valid if to avoid filtering the same aggregation field
 * @param {object} param1.defaultAuthFilter - once param1.filter is empty,
 *                                            use this auth related filter instead
 * @param {object} param1.nestedAggFields - fields for sub-aggregations
 *                                          (terms and/or missing aggregation)
 * @param {object} param1.nestedPath - path info used by nested aggregation
 */exports.numericHistogramWithFixedRangeStep = numericHistogramWithFixedRangeStep;
const numericHistogramWithFixedBinCount = async (
{
  esInstance,
  esIndex,
  esType
},
{
  filter,
  field,
  rangeStart,
  rangeEnd,
  binCount,
  filterSelf,
  defaultAuthFilter,
  nestedAggFields,
  nestedPath
}) =>
{
  const globalStats = await numericGlobalStats(
    {
      esInstance,
      esIndex,
      esType
    },
    {
      filter,
      field,
      rangeStart,
      rangeEnd,
      filterSelf,
      defaultAuthFilter,
      nestedAggFields,
      nestedPath
    }
  );
  const { min, max } = globalStats;
  const histogramStart = typeof rangeStart === 'undefined' ? min : rangeStart;
  const histogramEnd = typeof rangeEnd === 'undefined' ? max + 1 : rangeEnd;
  const rangeStep = (histogramEnd - histogramStart) / binCount;
  return numericHistogramWithFixedRangeStep(
    {
      esInstance,
      esIndex,
      esType
    },
    {
      filter,
      field,
      rangeStart: histogramStart,
      rangeEnd: histogramEnd,
      rangeStep,
      filterSelf,
      defaultAuthFilter,
      nestedAggFields,
      nestedPath
    }
  );
};

/**
 * This function does aggregation for numeric field, and returns histogram
 * @param {object} param0 - some ES related arguments: esInstance, esIndex, and esType
 * @param {object} param1 - some graphql related arguments
 * @param {object} param1.filter - filter (if any) to apply on aggregation
 * @param {object} param1.field - field to aggregate. Required
 * @param {object} param1.rangeStart - start value of the histogram, if empty, default to minimum
 * @param {object} param1.rangeEnd - end value of the histogram, if empty, default to maximum
 * @param {object} param1.rangeStep - histogram width, conflict with `binCount`
 * @param {object} param1.binCount - histogram bin count, conflict with `rangeStep`
 * @param {object} param1.filterSelf - only valid if to avoid filtering the same aggregation field
 * @param {object} param1.defaultAuthFilter - once param1.filter is empty,
 *                                            use this auth related filter instead
 * @param {object} param1.nestedAggFields - fields for sub-aggregations
 *                                          (terms and/or missing aggregation)
 * @param {object} param1.nestedPath - path info used by nested aggregation
 */exports.numericHistogramWithFixedBinCount = numericHistogramWithFixedBinCount;
const numericAggregation = async (
{
  esInstance,
  esIndex,
  esType
},
{
  filter,
  field,
  rangeStart,
  rangeEnd,
  rangeStep,
  binCount,
  filterSelf,
  defaultAuthFilter,
  nestedAggFields,
  nestedPath
}) =>
{
  if (rangeStep <= 0) {
    throw new _graphql.GraphQLError(`Invalid rangeStep ${rangeStep}`, {
      extensions: {
        code: 'BAD_USER_INPUT'
      }
    });
  }
  if (rangeStart > rangeEnd) {
    throw new _graphql.GraphQLError(`Invalid rangeStart (${rangeStep}) > rangeEnd (${rangeEnd})`, {
      extensions: {
        code: 'BAD_USER_INPUT'
      }
    });
  }
  if (binCount <= 0) {
    throw new _graphql.GraphQLError(`Invalid binCount ${binCount}`, {
      extensions: {
        code: 'BAD_USER_INPUT'
      }
    });
  }
  if (typeof rangeStep !== 'undefined' && typeof binCount !== 'undefined') {
    throw new _graphql.GraphQLError('Invalid to set "rangeStep" and "binCount" at same time', {
      extensions: {
        code: 'BAD_USER_INPUT'
      }
    });
  }
  if (typeof rangeStep !== 'undefined') {
    return numericHistogramWithFixedRangeStep(
      {
        esInstance,
        esIndex,
        esType
      },
      {
        esIndex,
        esType,
        filter,
        field,
        rangeStart,
        rangeEnd,
        rangeStep,
        filterSelf,
        defaultAuthFilter,
        nestedAggFields,
        nestedPath
      }
    );
  }
  if (typeof binCount !== 'undefined') {
    return numericHistogramWithFixedBinCount(
      {
        esInstance,
        esIndex,
        esType
      },
      {
        filter,
        field,
        rangeStart,
        rangeEnd,
        binCount,
        filterSelf,
        defaultAuthFilter,
        nestedAggFields,
        nestedPath
      }
    );
  }
  const result = await numericGlobalStats(
    {
      esInstance,
      esIndex,
      esType
    },
    {
      filter,
      field,
      rangeStart,
      rangeEnd,
      filterSelf,
      defaultAuthFilter,
      nestedAggFields,
      nestedPath
    }
  );
  return [result];
};

/**
 * This function does aggregation for text field, and returns histogram
 * @param {object} param0 - some ES related arguments: esInstance, esIndex, and esType
 * @param {object} param1 - some graphql related arguments
 * @param {object} param1.filter - filter (if any) to apply on aggregation
 * @param {object} param1.field - field to aggregate. Required
 * @param {object} param1.filterSelf - only valid if to avoid filtering the same aggregation field
 * @param {object} param1.defaultAuthFilter - once param1.filter is empty,
 *                                            use this auth related filter instead
 * @param {object} param1.nestedAggFields - fields for sub-aggregations
 *                                          (terms and/or missing aggregation)
 * @param {object} param1.nestedPath - path info used by nested aggregation
 */exports.numericAggregation = numericAggregation;
const textAggregation = async (
{
  esInstance,
  esIndex,
  esType
},
{
  filter,
  field,
  filterSelf,
  defaultAuthFilter,
  nestedAggFields,
  nestedPath,
  isNumericField
}) =>
{
  const queryBody = { size: 0 };
  if (!!filter || !!defaultAuthFilter) {
    queryBody.query = (0, _filter.default)(
      esInstance,
      esIndex,
      filter,
      field,
      filterSelf,
      defaultAuthFilter
    );
  }

  let missingAlias = {};
  // don't add missing alias to numeric field by default
  // since the value of missing alias is a string
  if (_config.default.esConfig.aggregationIncludeMissingData && !isNumericField) {
    missingAlias = { missing_bucket: true, order: 'desc' };
  }
  const aggsName = `${field}Aggs`;
  const aggsObj = {};
  let aggsNestedName;
  let fieldNestedName;
  if (nestedPath) {
    aggsNestedName = `${field}NestedAggs`;
    fieldNestedName = `${nestedPath}.${field}`;
  }

  if (nestedAggFields && nestedAggFields.termsFields) {
    missingAlias = {};
    aggsObj.aggs = updateAggObjectForTermsFields(nestedAggFields.termsFields, aggsObj.aggs);
  }

  if (nestedAggFields && nestedAggFields.missingFields) {
    missingAlias = {};
    aggsObj.aggs = updateAggObjectForMissingFields(nestedAggFields.missingFields, aggsObj.aggs);
  }

  // build up ES query if is nested aggregation
  if (aggsNestedName) {
    queryBody.aggs = {
      [aggsNestedName]: {
        nested: {
          path: nestedPath
        },
        aggs: {
          [aggsName]: {
            composite: {
              sources: [
              {
                [fieldNestedName]: {
                  terms: {
                    field: fieldNestedName,
                    ...missingAlias
                  }
                }
              }],

              size: PAGE_SIZE
            },
            ...aggsObj
          }
        }
      }
    };
  } else {
    queryBody.aggs = {
      [aggsName]: {
        composite: {
          sources: [
          {
            [field]: {
              terms: {
                field,
                ...missingAlias
              }
            }
          }],

          size: PAGE_SIZE
        },
        ...aggsObj
      }
    };
  }
  let resultSize;
  let finalResults = [];
  /* eslint-disable */
  do {
    // parse ES query result based on whether is doing nested aggregation or not (if `aggsNestedName` is defined)
    const result = await esInstance.query(esIndex, esType, queryBody);
    resultSize = 0;

    const resultBuckets = aggsNestedName ? result.aggregations[aggsNestedName][aggsName].buckets : result.aggregations[aggsName].buckets;
    resultBuckets.forEach((item) => {
      const resultObj = processResultsForNestedAgg(nestedAggFields, item, {});
      finalResults.push({
        key: fieldNestedName ? item.key[fieldNestedName] : item.key[field],
        count: item.doc_count,
        ...resultObj
      });
      resultSize += 1;
    });
    const afterKey = aggsNestedName ? result.aggregations[aggsNestedName][aggsName].after_key : result.aggregations[aggsName].after_key;
    if (typeof afterKey === 'undefined') break;
    aggsNestedName ? queryBody.aggs[aggsNestedName].aggs[aggsName].composite.after = afterKey : queryBody.aggs[aggsName].composite.after = afterKey;
  } while (resultSize === PAGE_SIZE);
  /* eslint-enable */

  // order aggregations by doc count
  finalResults = finalResults.sort((e1, e2) => {
    if (e1.key === null) return 1;
    if (e2.key === null) return -1;
    return e2.count - e1.count;
  });

  // make the missing data bucket to the bottom of the list
  const lastIndex = finalResults.length - 1;
  if (_config.default.esConfig.aggregationIncludeMissingData) {
    const missingDataItem = finalResults[lastIndex];
    if (missingDataItem !== undefined && missingDataItem.key === null) {
      missingDataItem.key = _config.default.esConfig.missingDataAlias;
      finalResults[lastIndex] = missingDataItem;
    }
  }
  return finalResults;
};exports.textAggregation = textAggregation;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfZ3JhcGhxbCIsInJlcXVpcmUiLCJfZmlsdGVyIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9jb25zdCIsIl9jb25maWciLCJlIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJQQUdFX1NJWkUiLCJ1cGRhdGVBZ2dPYmplY3RGb3JUZXJtc0ZpZWxkcyIsInRlcm1zRmllbGRzIiwiYWdnc09iaiIsIm5ld0FnZ3NPYmoiLCJmb3JFYWNoIiwiZWxlbWVudCIsInZhcmlhYmxlTmFtZSIsInRlcm1zIiwiZmllbGQiLCJzaXplIiwidXBkYXRlQWdnT2JqZWN0Rm9yTWlzc2luZ0ZpZWxkcyIsIm1pc3NpbmdGaWVsZHMiLCJtaXNzaW5nIiwicHJvY2Vzc1Jlc3VsdHNGb3JOZXN0ZWRBZ2ciLCJuZXN0ZWRBZ2dGaWVsZHMiLCJpdGVtIiwicmVzdWx0T2JqIiwibWlzc2luZ0ZpZWxkUmVzdWx0IiwicHVzaCIsImNvdW50IiwiZG9jX2NvdW50IiwidGVybXNGaWVsZFJlc3VsdCIsInRlbXBSZXN1bHQiLCJidWNrZXRzIiwibGVuZ3RoIiwiaXRlbUVsZW1lbnQiLCJrZXkiLCJuZXdSZXN1bHRPYmoiLCJhcHBlbmRBZGRpdGlvbmFsUmFuZ2VRdWVyeSIsIm9sZFF1ZXJ5IiwicmFuZ2VTdGFydCIsInJhbmdlRW5kIiwiYXBwZW5kRmlsdGVyIiwicmFuZ2UiLCJndGUiLCJsdCIsIm5ld1F1ZXJ5IiwiYm9vbCIsIm11c3QiLCJleHBvcnRzIiwibnVtZXJpY0dsb2JhbFN0YXRzIiwiZXNJbnN0YW5jZSIsImVzSW5kZXgiLCJlc1R5cGUiLCJmaWx0ZXIiLCJmaWx0ZXJTZWxmIiwiZGVmYXVsdEF1dGhGaWx0ZXIiLCJuZXN0ZWRQYXRoIiwicXVlcnlCb2R5IiwicXVlcnkiLCJnZXRGaWx0ZXJPYmoiLCJBR0dTX0dMT0JBTF9TVEFUU19OQU1FIiwic3RhdHMiLCJhZ2dzIiwiQUdHU19ORVNURURfUVVFUllfTkFNRSIsIm5lc3RlZCIsInBhdGgiLCJyZXN1bHQiLCJyZXN1bHRTdGF0cyIsImFnZ3JlZ2F0aW9ucyIsIm1pbiIsIm1heCIsIm51bWVyaWNIaXN0b2dyYW1XaXRoRml4ZWRSYW5nZVN0ZXAiLCJyYW5nZVN0ZXAiLCJBR0dTX1FVRVJZX05BTUUiLCJoaXN0b2dyYW0iLCJpbnRlcnZhbCIsIkFHR1NfSVRFTV9TVEFUU19OQU1FIiwib2Zmc2V0IiwiZmluYWxSZXN1bHRzIiwicmVzdWx0QnVja2V0cyIsIm51bWVyaWNIaXN0b2dyYW1XaXRoRml4ZWRCaW5Db3VudCIsImJpbkNvdW50IiwiZ2xvYmFsU3RhdHMiLCJoaXN0b2dyYW1TdGFydCIsImhpc3RvZ3JhbUVuZCIsIm51bWVyaWNBZ2dyZWdhdGlvbiIsIkdyYXBoUUxFcnJvciIsImV4dGVuc2lvbnMiLCJjb2RlIiwidGV4dEFnZ3JlZ2F0aW9uIiwiaXNOdW1lcmljRmllbGQiLCJtaXNzaW5nQWxpYXMiLCJjb25maWciLCJlc0NvbmZpZyIsImFnZ3JlZ2F0aW9uSW5jbHVkZU1pc3NpbmdEYXRhIiwibWlzc2luZ19idWNrZXQiLCJvcmRlciIsImFnZ3NOYW1lIiwiYWdnc05lc3RlZE5hbWUiLCJmaWVsZE5lc3RlZE5hbWUiLCJjb21wb3NpdGUiLCJzb3VyY2VzIiwicmVzdWx0U2l6ZSIsImFmdGVyS2V5IiwiYWZ0ZXJfa2V5IiwiYWZ0ZXIiLCJzb3J0IiwiZTEiLCJlMiIsImxhc3RJbmRleCIsIm1pc3NpbmdEYXRhSXRlbSIsInVuZGVmaW5lZCIsIm1pc3NpbmdEYXRhQWxpYXMiXSwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvc2VydmVyL2VzL2FnZ3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgR3JhcGhRTEVycm9yIH0gZnJvbSAnZ3JhcGhxbCc7XG5pbXBvcnQgZ2V0RmlsdGVyT2JqIGZyb20gJy4vZmlsdGVyJztcbmltcG9ydCB7XG4gIEFHR1NfR0xPQkFMX1NUQVRTX05BTUUsXG4gIEFHR1NfSVRFTV9TVEFUU19OQU1FLFxuICBBR0dTX05FU1RFRF9RVUVSWV9OQU1FLFxuICBBR0dTX1FVRVJZX05BTUUsXG59IGZyb20gJy4vY29uc3QnO1xuaW1wb3J0IGNvbmZpZyBmcm9tICcuLi9jb25maWcnO1xuXG5jb25zdCBQQUdFX1NJWkUgPSAxMDAwMDtcblxuY29uc3QgdXBkYXRlQWdnT2JqZWN0Rm9yVGVybXNGaWVsZHMgPSAodGVybXNGaWVsZHMsIGFnZ3NPYmopID0+IHtcbiAgY29uc3QgbmV3QWdnc09iaiA9IHsgLi4uYWdnc09iaiB9O1xuICB0ZXJtc0ZpZWxkcy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgdmFyaWFibGVOYW1lID0gYCR7ZWxlbWVudH1UZXJtc2A7XG4gICAgbmV3QWdnc09ialt2YXJpYWJsZU5hbWVdID0ge1xuICAgICAgdGVybXM6IHtcbiAgICAgICAgZmllbGQ6IGVsZW1lbnQsXG4gICAgICAgIHNpemU6IFBBR0VfU0laRSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiBuZXdBZ2dzT2JqO1xufTtcblxuY29uc3QgdXBkYXRlQWdnT2JqZWN0Rm9yTWlzc2luZ0ZpZWxkcyA9IChtaXNzaW5nRmllbGRzLCBhZ2dzT2JqKSA9PiB7XG4gIGNvbnN0IG5ld0FnZ3NPYmogPSB7IC4uLmFnZ3NPYmogfTtcbiAgbWlzc2luZ0ZpZWxkcy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgdmFyaWFibGVOYW1lID0gYCR7ZWxlbWVudH1NaXNzaW5nYDtcbiAgICBuZXdBZ2dzT2JqW3ZhcmlhYmxlTmFtZV0gPSB7XG4gICAgICBtaXNzaW5nOiB7XG4gICAgICAgIGZpZWxkOiBlbGVtZW50LFxuICAgICAgfSxcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIG5ld0FnZ3NPYmo7XG59O1xuXG5jb25zdCBwcm9jZXNzUmVzdWx0c0Zvck5lc3RlZEFnZyA9IChuZXN0ZWRBZ2dGaWVsZHMsIGl0ZW0sIHJlc3VsdE9iaikgPT4ge1xuICBsZXQgbWlzc2luZ0ZpZWxkUmVzdWx0O1xuICBpZiAobmVzdGVkQWdnRmllbGRzICYmIG5lc3RlZEFnZ0ZpZWxkcy5taXNzaW5nRmllbGRzKSB7XG4gICAgbWlzc2luZ0ZpZWxkUmVzdWx0ID0gW107XG4gICAgbmVzdGVkQWdnRmllbGRzLm1pc3NpbmdGaWVsZHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3QgdmFyaWFibGVOYW1lID0gYCR7ZWxlbWVudH1NaXNzaW5nYDtcbiAgICAgIG1pc3NpbmdGaWVsZFJlc3VsdC5wdXNoKHtcbiAgICAgICAgZmllbGQ6IGVsZW1lbnQsXG4gICAgICAgIGNvdW50OiBpdGVtW3ZhcmlhYmxlTmFtZV0uZG9jX2NvdW50LFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBsZXQgdGVybXNGaWVsZFJlc3VsdDtcbiAgaWYgKG5lc3RlZEFnZ0ZpZWxkcyAmJiBuZXN0ZWRBZ2dGaWVsZHMudGVybXNGaWVsZHMpIHtcbiAgICB0ZXJtc0ZpZWxkUmVzdWx0ID0gW107XG4gICAgbmVzdGVkQWdnRmllbGRzLnRlcm1zRmllbGRzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IHRlbXBSZXN1bHQgPSB7fTtcbiAgICAgIHRlbXBSZXN1bHQuZmllbGQgPSBlbGVtZW50O1xuICAgICAgdGVtcFJlc3VsdC50ZXJtcyA9IFtdO1xuICAgICAgdGVtcFJlc3VsdC5jb3VudCA9IDA7XG4gICAgICBjb25zdCB2YXJpYWJsZU5hbWUgPSBgJHtlbGVtZW50fVRlcm1zYDtcbiAgICAgIGlmIChpdGVtW3ZhcmlhYmxlTmFtZV0uYnVja2V0cyAmJiBpdGVtW3ZhcmlhYmxlTmFtZV0uYnVja2V0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGl0ZW1bdmFyaWFibGVOYW1lXS5idWNrZXRzLmZvckVhY2goKGl0ZW1FbGVtZW50KSA9PiB7XG4gICAgICAgICAgdGVtcFJlc3VsdC50ZXJtcy5wdXNoKHtcbiAgICAgICAgICAgIGtleTogaXRlbUVsZW1lbnQua2V5LFxuICAgICAgICAgICAgY291bnQ6IGl0ZW1FbGVtZW50LmRvY19jb3VudCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0ZW1wUmVzdWx0LmNvdW50ICs9IGl0ZW1FbGVtZW50LmRvY19jb3VudDtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wUmVzdWx0LnRlcm1zLnB1c2goe1xuICAgICAgICAgIGtleTogbnVsbCxcbiAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0ZXJtc0ZpZWxkUmVzdWx0LnB1c2godGVtcFJlc3VsdCk7XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBuZXdSZXN1bHRPYmogPSB7XG4gICAgLi4ucmVzdWx0T2JqLFxuICAgIC4uLihtaXNzaW5nRmllbGRSZXN1bHQgJiYgeyBtaXNzaW5nRmllbGRzOiBtaXNzaW5nRmllbGRSZXN1bHQgfSksXG4gICAgLi4uKHRlcm1zRmllbGRSZXN1bHQgJiYgeyB0ZXJtc0ZpZWxkczogdGVybXNGaWVsZFJlc3VsdCB9KSxcbiAgfTtcbiAgcmV0dXJuIG5ld1Jlc3VsdE9iajtcbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhcHBlbmRzIGV4dHJhIHJhbmdlIGxpbWl0YXRpb24gb250byBhIHF1ZXJ5IGJvZHkgXCJvbGRRdWVyeVwiXG4gKiBleHBvcnQgZm9yIHRlc3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCAtIHdoaWNoIGZpZWxkIHRvIGFwcGVuZCByYW5nZSBsaW1pdGF0aW9uIHRvXG4gKiBAcGFyYW0ge29iamVjdH0gb2xkUXVlcnkgIC0gdGhlIG9sZCBxdWVyeSBib2R5IHRvIGFwcGVuZFxuICogQHBhcmFtIHtudW1iZXJ9IHJhbmdlU3RhcnQgLSB0aGUgcmFuZ2Ugc3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSByYW5nZUVuZCAtIHRoZSByYW5nZSBlbmRcbiAqL1xuZXhwb3J0IGNvbnN0IGFwcGVuZEFkZGl0aW9uYWxSYW5nZVF1ZXJ5ID0gKGZpZWxkLCBvbGRRdWVyeSwgcmFuZ2VTdGFydCwgcmFuZ2VFbmQpID0+IHtcbiAgY29uc3QgYXBwZW5kRmlsdGVyID0gW107XG4gIGlmICh0eXBlb2YgcmFuZ2VTdGFydCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBhcHBlbmRGaWx0ZXIucHVzaCh7XG4gICAgICByYW5nZToge1xuICAgICAgICBbZmllbGRdOiB7IGd0ZTogcmFuZ2VTdGFydCB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIHJhbmdlRW5kICE9PSAndW5kZWZpbmVkJykge1xuICAgIGFwcGVuZEZpbHRlci5wdXNoKHtcbiAgICAgIHJhbmdlOiB7XG4gICAgICAgIFtmaWVsZF06IHsgbHQ6IHJhbmdlRW5kIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG4gIGlmIChhcHBlbmRGaWx0ZXIubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IG5ld1F1ZXJ5ID0ge1xuICAgICAgYm9vbDoge1xuICAgICAgICBtdXN0OiBvbGRRdWVyeSA/IFtcbiAgICAgICAgICBvbGRRdWVyeSxcbiAgICAgICAgICBbLi4uYXBwZW5kRmlsdGVyXSxcbiAgICAgICAgXSA6IFsuLi5hcHBlbmRGaWx0ZXJdLFxuICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBuZXdRdWVyeTtcbiAgfVxuICByZXR1cm4gb2xkUXVlcnk7XG59O1xuXG4vKipcbiAqIGdldCBnbG9iYWwgc3RhdHMgZm9yIGEgZmllbGRcbiAqIEV4cG9ydCBmb3IgdGVzdFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtMCAtIHNvbWUgRVMgcmVsYXRlZCBhcmd1bWVudHM6IGVzSW5zdGFuY2UsIGVzSW5kZXgsIGFuZCBlc1R5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbTEgLSBzb21lIGdyYXBocWwgcmVsYXRlZCBhcmd1bWVudHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbTEuZmlsdGVyIC0gZmlsdGVyIChpZiBhbnkpIHRvIGFwcGx5IG9uIGFnZ3JlZ2F0aW9uXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW0xLmZpZWxkIC0gZmllbGQgdG8gYWdncmVnYXRlLiBSZXF1aXJlZFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtMS5yYW5nZVN0YXJ0IC0gc3RhcnQgdmFsdWUgb2YgdGhlIGhpc3RvZ3JhbSwgaWYgZW1wdHksIGRlZmF1bHQgdG8gbWluaW11bVxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtMS5yYW5nZUVuZCAtIGVuZCB2YWx1ZSBvZiB0aGUgaGlzdG9ncmFtLCBpZiBlbXB0eSwgZGVmYXVsdCB0byBtYXhpbXVtXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW0xLnJhbmdlU3RlcCAtIGhpc3RvZ3JhbSB3aWR0aC4gUmVxdWlyZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW0xLmZpbHRlclNlbGYgLSBvbmx5IHZhbGlkIGlmIHRvIGF2b2lkIGZpbHRlcmluZyB0aGUgc2FtZSBhZ2dyZWdhdGlvbiBmaWVsZFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtMS5kZWZhdWx0QXV0aEZpbHRlciAtIG9uY2UgcGFyYW0xLmZpbHRlciBpcyBlbXB0eSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2UgdGhpcyBhdXRoIHJlbGF0ZWQgZmlsdGVyIGluc3RlYWRcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbTEubmVzdGVkQWdnRmllbGRzIC0gZmllbGRzIGZvciBzdWItYWdncmVnYXRpb25zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0ZXJtcyBhbmQvb3IgbWlzc2luZyBhZ2dyZWdhdGlvbilcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbTEubmVzdGVkUGF0aCAtIHBhdGggaW5mbyB1c2VkIGJ5IG5lc3RlZCBhZ2dyZWdhdGlvblxuICogQHJldHVybnMge21pbiwgbWF4LCBzdW0sIGNvdW50LCBhdmcsIGtleX1cbiAqL1xuZXhwb3J0IGNvbnN0IG51bWVyaWNHbG9iYWxTdGF0cyA9IGFzeW5jIChcbiAge1xuICAgIGVzSW5zdGFuY2UsXG4gICAgZXNJbmRleCxcbiAgICBlc1R5cGUsXG4gIH0sXG4gIHtcbiAgICBmaWx0ZXIsXG4gICAgZmllbGQsXG4gICAgcmFuZ2VTdGFydCxcbiAgICByYW5nZUVuZCxcbiAgICBmaWx0ZXJTZWxmLFxuICAgIGRlZmF1bHRBdXRoRmlsdGVyLFxuICAgIG5lc3RlZEFnZ0ZpZWxkcyxcbiAgICBuZXN0ZWRQYXRoLFxuICB9LFxuKSA9PiB7XG4gIGNvbnN0IHF1ZXJ5Qm9keSA9IHsgc2l6ZTogMCB9O1xuICBpZiAoISFmaWx0ZXIgfHwgISFkZWZhdWx0QXV0aEZpbHRlcikge1xuICAgIHF1ZXJ5Qm9keS5xdWVyeSA9IGdldEZpbHRlck9iaihcbiAgICAgIGVzSW5zdGFuY2UsXG4gICAgICBlc0luZGV4LFxuICAgICAgZmlsdGVyLFxuICAgICAgZmllbGQsXG4gICAgICBmaWx0ZXJTZWxmLFxuICAgICAgZGVmYXVsdEF1dGhGaWx0ZXIsXG4gICAgKTtcbiAgfVxuICBxdWVyeUJvZHkucXVlcnkgPSBhcHBlbmRBZGRpdGlvbmFsUmFuZ2VRdWVyeShmaWVsZCwgcXVlcnlCb2R5LnF1ZXJ5LCByYW5nZVN0YXJ0LCByYW5nZUVuZCk7XG4gIGxldCBhZ2dzT2JqID0ge1xuICAgIFtBR0dTX0dMT0JBTF9TVEFUU19OQU1FXToge1xuICAgICAgc3RhdHM6IHtcbiAgICAgICAgZmllbGQ6IChuZXN0ZWRQYXRoKSA/IGAke25lc3RlZFBhdGh9LiR7ZmllbGR9YCA6IGAke2ZpZWxkfWAsXG4gICAgICB9LFxuICAgIH0sXG4gIH07XG4gIGlmIChuZXN0ZWRBZ2dGaWVsZHMgJiYgbmVzdGVkQWdnRmllbGRzLnRlcm1zRmllbGRzKSB7XG4gICAgYWdnc09iaiA9IHVwZGF0ZUFnZ09iamVjdEZvclRlcm1zRmllbGRzKG5lc3RlZEFnZ0ZpZWxkcy50ZXJtc0ZpZWxkcywgYWdnc09iaik7XG4gIH1cbiAgaWYgKG5lc3RlZEFnZ0ZpZWxkcyAmJiBuZXN0ZWRBZ2dGaWVsZHMubWlzc2luZ0ZpZWxkcykge1xuICAgIGFnZ3NPYmogPSB1cGRhdGVBZ2dPYmplY3RGb3JNaXNzaW5nRmllbGRzKG5lc3RlZEFnZ0ZpZWxkcy5taXNzaW5nRmllbGRzLCBhZ2dzT2JqKTtcbiAgfVxuICBpZiAobmVzdGVkUGF0aCkge1xuICAgIHF1ZXJ5Qm9keS5hZ2dzID0ge1xuICAgICAgW0FHR1NfTkVTVEVEX1FVRVJZX05BTUVdOiB7XG4gICAgICAgIG5lc3RlZDoge1xuICAgICAgICAgIHBhdGg6IG5lc3RlZFBhdGgsXG4gICAgICAgIH0sXG4gICAgICAgIGFnZ3M6IHtcbiAgICAgICAgICAuLi5hZ2dzT2JqLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHF1ZXJ5Qm9keS5hZ2dzID0gYWdnc09iajtcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGVzSW5zdGFuY2UucXVlcnkoZXNJbmRleCwgZXNUeXBlLCBxdWVyeUJvZHkpO1xuICBsZXQgcmVzdWx0U3RhdHMgPSAobmVzdGVkUGF0aClcbiAgICA/IHJlc3VsdC5hZ2dyZWdhdGlvbnNbQUdHU19ORVNURURfUVVFUllfTkFNRV1bQUdHU19HTE9CQUxfU1RBVFNfTkFNRV1cbiAgICA6IHJlc3VsdC5hZ2dyZWdhdGlvbnNbQUdHU19HTE9CQUxfU1RBVFNfTkFNRV07XG4gIGNvbnN0IHJhbmdlID0gW1xuICAgIHR5cGVvZiByYW5nZVN0YXJ0ID09PSAndW5kZWZpbmVkJyA/IHJlc3VsdFN0YXRzLm1pbiA6IHJhbmdlU3RhcnQsXG4gICAgdHlwZW9mIHJhbmdlRW5kID09PSAndW5kZWZpbmVkJyA/IHJlc3VsdFN0YXRzLm1heCA6IHJhbmdlRW5kLFxuICBdO1xuICByZXN1bHRTdGF0cyA9IHtcbiAgICBrZXk6IHJhbmdlLFxuICAgIC4uLnJlc3VsdFN0YXRzLFxuICB9O1xuICByZXN1bHRTdGF0cyA9IHByb2Nlc3NSZXN1bHRzRm9yTmVzdGVkQWdnKG5lc3RlZEFnZ0ZpZWxkcywgcmVzdWx0LmFnZ3JlZ2F0aW9ucywgcmVzdWx0U3RhdHMpO1xuICByZXR1cm4gcmVzdWx0U3RhdHM7XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBhZ2dyZWdhdGlvbiBmb3IgbnVtZXJpYyBmaWVsZCwgYW5kIHJldHVybnMgaGlzdG9ncmFtIHdpdGggZ2l2ZW4gd2lkdGguXG4gKiBFeHBvcnQgZm9yIHRlc3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbTAgLSBzb21lIEVTIHJlbGF0ZWQgYXJndW1lbnRzOiBlc0luc3RhbmNlLCBlc0luZGV4LCBhbmQgZXNUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW0xIC0gc29tZSBncmFwaHFsIHJlbGF0ZWQgYXJndW1lbnRzXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW0xLmZpbHRlciAtIGZpbHRlciAoaWYgYW55KSB0byBhcHBseSBvbiBhZ2dyZWdhdGlvblxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtMS5maWVsZCAtIGZpZWxkIHRvIGFnZ3JlZ2F0ZS4gUmVxdWlyZWRcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbTEucmFuZ2VTdGFydCAtIHN0YXJ0IHZhbHVlIG9mIHRoZSBoaXN0b2dyYW0sIGlmIGVtcHR5LCBkZWZhdWx0IHRvIG1pbmltdW1cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbTEucmFuZ2VFbmQgLSBlbmQgdmFsdWUgb2YgdGhlIGhpc3RvZ3JhbSwgaWYgZW1wdHksIGRlZmF1bHQgdG8gbWF4aW11bVxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtMS5yYW5nZVN0ZXAgLSBoaXN0b2dyYW0gd2lkdGguIFJlcXVpcmVkLlxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtMS5maWx0ZXJTZWxmIC0gb25seSB2YWxpZCBpZiB0byBhdm9pZCBmaWx0ZXJpbmcgdGhlIHNhbWUgYWdncmVnYXRpb24gZmllbGRcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbTEuZGVmYXVsdEF1dGhGaWx0ZXIgLSBvbmNlIHBhcmFtMS5maWx0ZXIgaXMgZW1wdHksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlIHRoaXMgYXV0aCByZWxhdGVkIGZpbHRlciBpbnN0ZWFkXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW0xLm5lc3RlZEFnZ0ZpZWxkcyAtIGZpZWxkcyBmb3Igc3ViLWFnZ3JlZ2F0aW9uc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGVybXMgYW5kL29yIG1pc3NpbmcgYWdncmVnYXRpb24pXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW0xLm5lc3RlZFBhdGggLSBwYXRoIGluZm8gdXNlZCBieSBuZXN0ZWQgYWdncmVnYXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IG51bWVyaWNIaXN0b2dyYW1XaXRoRml4ZWRSYW5nZVN0ZXAgPSBhc3luYyAoXG4gIHtcbiAgICBlc0luc3RhbmNlLFxuICAgIGVzSW5kZXgsXG4gICAgZXNUeXBlLFxuICB9LFxuICB7XG4gICAgZmlsdGVyLFxuICAgIGZpZWxkLFxuICAgIHJhbmdlU3RhcnQsXG4gICAgcmFuZ2VFbmQsXG4gICAgcmFuZ2VTdGVwLFxuICAgIGZpbHRlclNlbGYsXG4gICAgZGVmYXVsdEF1dGhGaWx0ZXIsXG4gICAgbmVzdGVkQWdnRmllbGRzLFxuICAgIG5lc3RlZFBhdGgsXG4gIH0sXG4pID0+IHtcbiAgY29uc3QgcXVlcnlCb2R5ID0geyBzaXplOiAwIH07XG4gIGlmICghIWZpbHRlciB8fCAhIWRlZmF1bHRBdXRoRmlsdGVyKSB7XG4gICAgcXVlcnlCb2R5LnF1ZXJ5ID0gZ2V0RmlsdGVyT2JqKFxuICAgICAgZXNJbnN0YW5jZSxcbiAgICAgIGVzSW5kZXgsXG4gICAgICBmaWx0ZXIsXG4gICAgICBmaWVsZCxcbiAgICAgIGZpbHRlclNlbGYsXG4gICAgICBkZWZhdWx0QXV0aEZpbHRlcixcbiAgICAgIG5lc3RlZEFnZ0ZpZWxkcyxcbiAgICApO1xuICB9XG4gIHF1ZXJ5Qm9keS5xdWVyeSA9IGFwcGVuZEFkZGl0aW9uYWxSYW5nZVF1ZXJ5KGZpZWxkLCBxdWVyeUJvZHkucXVlcnksIHJhbmdlU3RhcnQsIHJhbmdlRW5kKTtcbiAgY29uc3QgYWdnc09iaiA9IHtcbiAgICBbQUdHU19HTE9CQUxfU1RBVFNfTkFNRV06IHtcbiAgICAgIHN0YXRzOiB7XG4gICAgICAgIGZpZWxkOiAobmVzdGVkUGF0aCkgPyBgJHtuZXN0ZWRQYXRofS4ke2ZpZWxkfWAgOiBgJHtmaWVsZH1gLFxuICAgICAgfSxcbiAgICB9LFxuICB9O1xuICBhZ2dzT2JqW0FHR1NfUVVFUllfTkFNRV0gPSB7XG4gICAgaGlzdG9ncmFtOiB7XG4gICAgICBmaWVsZDogKG5lc3RlZFBhdGgpID8gYCR7bmVzdGVkUGF0aH0uJHtmaWVsZH1gIDogYCR7ZmllbGR9YCxcbiAgICAgIGludGVydmFsOiByYW5nZVN0ZXAsXG4gICAgfSxcbiAgICBhZ2dzOiB7XG4gICAgICBbQUdHU19JVEVNX1NUQVRTX05BTUVdOiB7XG4gICAgICAgIHN0YXRzOiB7XG4gICAgICAgICAgZmllbGQ6IChuZXN0ZWRQYXRoKSA/IGAke25lc3RlZFBhdGh9LiR7ZmllbGR9YCA6IGAke2ZpZWxkfWAsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gIH07XG4gIGlmICh0eXBlb2YgcmFuZ2VTdGFydCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsZXQgb2Zmc2V0ID0gcmFuZ2VTdGFydDtcbiAgICB3aGlsZSAob2Zmc2V0IC0gcmFuZ2VTdGVwID4gMCkge1xuICAgICAgb2Zmc2V0IC09IHJhbmdlU3RlcDtcbiAgICB9XG4gICAgYWdnc09ialtBR0dTX1FVRVJZX05BTUVdLmhpc3RvZ3JhbS5vZmZzZXQgPSBvZmZzZXQ7XG4gIH1cbiAgaWYgKG5lc3RlZEFnZ0ZpZWxkcyAmJiBuZXN0ZWRBZ2dGaWVsZHMudGVybXNGaWVsZHMpIHtcbiAgICBhZ2dzT2JqW0FHR1NfUVVFUllfTkFNRV0uYWdncyA9IHVwZGF0ZUFnZ09iamVjdEZvclRlcm1zRmllbGRzKFxuICAgICAgbmVzdGVkQWdnRmllbGRzLnRlcm1zRmllbGRzLFxuICAgICAgYWdnc09ialtBR0dTX1FVRVJZX05BTUVdLmFnZ3MsXG4gICAgKTtcbiAgfVxuICBpZiAobmVzdGVkQWdnRmllbGRzICYmIG5lc3RlZEFnZ0ZpZWxkcy5taXNzaW5nRmllbGRzKSB7XG4gICAgYWdnc09ialtBR0dTX1FVRVJZX05BTUVdLmFnZ3MgPSB1cGRhdGVBZ2dPYmplY3RGb3JNaXNzaW5nRmllbGRzKFxuICAgICAgbmVzdGVkQWdnRmllbGRzLm1pc3NpbmdGaWVsZHMsXG4gICAgICBhZ2dzT2JqW0FHR1NfUVVFUllfTkFNRV0uYWdncyxcbiAgICApO1xuICB9XG5cbiAgaWYgKG5lc3RlZFBhdGgpIHtcbiAgICBxdWVyeUJvZHkuYWdncyA9IHtcbiAgICAgIFtBR0dTX05FU1RFRF9RVUVSWV9OQU1FXToge1xuICAgICAgICBuZXN0ZWQ6IHtcbiAgICAgICAgICBwYXRoOiBuZXN0ZWRQYXRoLFxuICAgICAgICB9LFxuICAgICAgICBhZ2dzOiB7XG4gICAgICAgICAgLi4uYWdnc09iaixcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBxdWVyeUJvZHkuYWdncyA9IGFnZ3NPYmo7XG4gIH1cblxuICBjb25zdCByZXN1bHQgPSBhd2FpdCBlc0luc3RhbmNlLnF1ZXJ5KGVzSW5kZXgsIGVzVHlwZSwgcXVlcnlCb2R5KTtcbiAgY29uc3QgZmluYWxSZXN1bHRzID0gW107XG4gIGxldCByZXN1bHRPYmo7XG4gIGNvbnN0IHJlc3VsdEJ1Y2tldHMgPSAobmVzdGVkUGF0aClcbiAgICA/IHJlc3VsdC5hZ2dyZWdhdGlvbnNbQUdHU19ORVNURURfUVVFUllfTkFNRV1bQUdHU19RVUVSWV9OQU1FXS5idWNrZXRzXG4gICAgOiByZXN1bHQuYWdncmVnYXRpb25zW0FHR1NfUVVFUllfTkFNRV0uYnVja2V0cztcbiAgcmVzdWx0QnVja2V0cy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgcmVzdWx0T2JqID0gcHJvY2Vzc1Jlc3VsdHNGb3JOZXN0ZWRBZ2cobmVzdGVkQWdnRmllbGRzLCBpdGVtLCByZXN1bHRPYmopO1xuICAgIGZpbmFsUmVzdWx0cy5wdXNoKHtcbiAgICAgIGtleTogW2l0ZW0ua2V5LCBpdGVtLmtleSArIHJhbmdlU3RlcF0sXG4gICAgICAuLi5pdGVtW0FHR1NfSVRFTV9TVEFUU19OQU1FXSxcbiAgICAgIC4uLnJlc3VsdE9iaixcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBmaW5hbFJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBhZ2dyZWdhdGlvbiBmb3IgbnVtZXJpYyBmaWVsZCwgYW5kIHJldHVybnMgaGlzdG9ncmFtIHdpdGggZml4ZWQgYmluIGNvdW50LlxuICogRXhwb3J0IGZvciB0ZXN0XG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW0wIC0gc29tZSBFUyByZWxhdGVkIGFyZ3VtZW50czogZXNJbnN0YW5jZSwgZXNJbmRleCwgYW5kIGVzVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtMSAtIHNvbWUgZ3JhcGhxbCByZWxhdGVkIGFyZ3VtZW50c1xuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtMS5maWx0ZXIgLSBmaWx0ZXIgKGlmIGFueSkgdG8gYXBwbHkgb24gYWdncmVnYXRpb25cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbTEuZmllbGQgLSBmaWVsZCB0byBhZ2dyZWdhdGUuIFJlcXVpcmVkXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW0xLnJhbmdlU3RhcnQgLSBzdGFydCB2YWx1ZSBvZiB0aGUgaGlzdG9ncmFtLCBpZiBlbXB0eSwgZGVmYXVsdCB0byBtaW5pbXVtXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW0xLnJhbmdlRW5kIC0gZW5kIHZhbHVlIG9mIHRoZSBoaXN0b2dyYW0sIGlmIGVtcHR5LCBkZWZhdWx0IHRvIG1heGltdW1cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbTEuYmluQ291bnQgLSBoaXN0b2dyYW0gYmluIGNvdW50LiBSZXF1aXJlZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbTEuZmlsdGVyU2VsZiAtIG9ubHkgdmFsaWQgaWYgdG8gYXZvaWQgZmlsdGVyaW5nIHRoZSBzYW1lIGFnZ3JlZ2F0aW9uIGZpZWxkXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW0xLmRlZmF1bHRBdXRoRmlsdGVyIC0gb25jZSBwYXJhbTEuZmlsdGVyIGlzIGVtcHR5LFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZSB0aGlzIGF1dGggcmVsYXRlZCBmaWx0ZXIgaW5zdGVhZFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtMS5uZXN0ZWRBZ2dGaWVsZHMgLSBmaWVsZHMgZm9yIHN1Yi1hZ2dyZWdhdGlvbnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRlcm1zIGFuZC9vciBtaXNzaW5nIGFnZ3JlZ2F0aW9uKVxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtMS5uZXN0ZWRQYXRoIC0gcGF0aCBpbmZvIHVzZWQgYnkgbmVzdGVkIGFnZ3JlZ2F0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBudW1lcmljSGlzdG9ncmFtV2l0aEZpeGVkQmluQ291bnQgPSBhc3luYyAoXG4gIHtcbiAgICBlc0luc3RhbmNlLFxuICAgIGVzSW5kZXgsXG4gICAgZXNUeXBlLFxuICB9LFxuICB7XG4gICAgZmlsdGVyLFxuICAgIGZpZWxkLFxuICAgIHJhbmdlU3RhcnQsXG4gICAgcmFuZ2VFbmQsXG4gICAgYmluQ291bnQsXG4gICAgZmlsdGVyU2VsZixcbiAgICBkZWZhdWx0QXV0aEZpbHRlcixcbiAgICBuZXN0ZWRBZ2dGaWVsZHMsXG4gICAgbmVzdGVkUGF0aCxcbiAgfSxcbikgPT4ge1xuICBjb25zdCBnbG9iYWxTdGF0cyA9IGF3YWl0IG51bWVyaWNHbG9iYWxTdGF0cyhcbiAgICB7XG4gICAgICBlc0luc3RhbmNlLFxuICAgICAgZXNJbmRleCxcbiAgICAgIGVzVHlwZSxcbiAgICB9LFxuICAgIHtcbiAgICAgIGZpbHRlcixcbiAgICAgIGZpZWxkLFxuICAgICAgcmFuZ2VTdGFydCxcbiAgICAgIHJhbmdlRW5kLFxuICAgICAgZmlsdGVyU2VsZixcbiAgICAgIGRlZmF1bHRBdXRoRmlsdGVyLFxuICAgICAgbmVzdGVkQWdnRmllbGRzLFxuICAgICAgbmVzdGVkUGF0aCxcbiAgICB9LFxuICApO1xuICBjb25zdCB7IG1pbiwgbWF4IH0gPSBnbG9iYWxTdGF0cztcbiAgY29uc3QgaGlzdG9ncmFtU3RhcnQgPSB0eXBlb2YgcmFuZ2VTdGFydCA9PT0gJ3VuZGVmaW5lZCcgPyBtaW4gOiByYW5nZVN0YXJ0O1xuICBjb25zdCBoaXN0b2dyYW1FbmQgPSB0eXBlb2YgcmFuZ2VFbmQgPT09ICd1bmRlZmluZWQnID8gKG1heCArIDEpIDogcmFuZ2VFbmQ7XG4gIGNvbnN0IHJhbmdlU3RlcCA9IChoaXN0b2dyYW1FbmQgLSBoaXN0b2dyYW1TdGFydCkgLyBiaW5Db3VudDtcbiAgcmV0dXJuIG51bWVyaWNIaXN0b2dyYW1XaXRoRml4ZWRSYW5nZVN0ZXAoXG4gICAge1xuICAgICAgZXNJbnN0YW5jZSxcbiAgICAgIGVzSW5kZXgsXG4gICAgICBlc1R5cGUsXG4gICAgfSxcbiAgICB7XG4gICAgICBmaWx0ZXIsXG4gICAgICBmaWVsZCxcbiAgICAgIHJhbmdlU3RhcnQ6IGhpc3RvZ3JhbVN0YXJ0LFxuICAgICAgcmFuZ2VFbmQ6IGhpc3RvZ3JhbUVuZCxcbiAgICAgIHJhbmdlU3RlcCxcbiAgICAgIGZpbHRlclNlbGYsXG4gICAgICBkZWZhdWx0QXV0aEZpbHRlcixcbiAgICAgIG5lc3RlZEFnZ0ZpZWxkcyxcbiAgICAgIG5lc3RlZFBhdGgsXG4gICAgfSxcbiAgKTtcbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIGFnZ3JlZ2F0aW9uIGZvciBudW1lcmljIGZpZWxkLCBhbmQgcmV0dXJucyBoaXN0b2dyYW1cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbTAgLSBzb21lIEVTIHJlbGF0ZWQgYXJndW1lbnRzOiBlc0luc3RhbmNlLCBlc0luZGV4LCBhbmQgZXNUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW0xIC0gc29tZSBncmFwaHFsIHJlbGF0ZWQgYXJndW1lbnRzXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW0xLmZpbHRlciAtIGZpbHRlciAoaWYgYW55KSB0byBhcHBseSBvbiBhZ2dyZWdhdGlvblxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtMS5maWVsZCAtIGZpZWxkIHRvIGFnZ3JlZ2F0ZS4gUmVxdWlyZWRcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbTEucmFuZ2VTdGFydCAtIHN0YXJ0IHZhbHVlIG9mIHRoZSBoaXN0b2dyYW0sIGlmIGVtcHR5LCBkZWZhdWx0IHRvIG1pbmltdW1cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbTEucmFuZ2VFbmQgLSBlbmQgdmFsdWUgb2YgdGhlIGhpc3RvZ3JhbSwgaWYgZW1wdHksIGRlZmF1bHQgdG8gbWF4aW11bVxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtMS5yYW5nZVN0ZXAgLSBoaXN0b2dyYW0gd2lkdGgsIGNvbmZsaWN0IHdpdGggYGJpbkNvdW50YFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtMS5iaW5Db3VudCAtIGhpc3RvZ3JhbSBiaW4gY291bnQsIGNvbmZsaWN0IHdpdGggYHJhbmdlU3RlcGBcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbTEuZmlsdGVyU2VsZiAtIG9ubHkgdmFsaWQgaWYgdG8gYXZvaWQgZmlsdGVyaW5nIHRoZSBzYW1lIGFnZ3JlZ2F0aW9uIGZpZWxkXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW0xLmRlZmF1bHRBdXRoRmlsdGVyIC0gb25jZSBwYXJhbTEuZmlsdGVyIGlzIGVtcHR5LFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZSB0aGlzIGF1dGggcmVsYXRlZCBmaWx0ZXIgaW5zdGVhZFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtMS5uZXN0ZWRBZ2dGaWVsZHMgLSBmaWVsZHMgZm9yIHN1Yi1hZ2dyZWdhdGlvbnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRlcm1zIGFuZC9vciBtaXNzaW5nIGFnZ3JlZ2F0aW9uKVxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtMS5uZXN0ZWRQYXRoIC0gcGF0aCBpbmZvIHVzZWQgYnkgbmVzdGVkIGFnZ3JlZ2F0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBudW1lcmljQWdncmVnYXRpb24gPSBhc3luYyAoXG4gIHtcbiAgICBlc0luc3RhbmNlLFxuICAgIGVzSW5kZXgsXG4gICAgZXNUeXBlLFxuICB9LFxuICB7XG4gICAgZmlsdGVyLFxuICAgIGZpZWxkLFxuICAgIHJhbmdlU3RhcnQsXG4gICAgcmFuZ2VFbmQsXG4gICAgcmFuZ2VTdGVwLFxuICAgIGJpbkNvdW50LFxuICAgIGZpbHRlclNlbGYsXG4gICAgZGVmYXVsdEF1dGhGaWx0ZXIsXG4gICAgbmVzdGVkQWdnRmllbGRzLFxuICAgIG5lc3RlZFBhdGgsXG4gIH0sXG4pID0+IHtcbiAgaWYgKHJhbmdlU3RlcCA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEdyYXBoUUxFcnJvcihgSW52YWxpZCByYW5nZVN0ZXAgJHtyYW5nZVN0ZXB9YCwge1xuICAgICAgZXh0ZW5zaW9uczoge1xuICAgICAgICBjb2RlOiAnQkFEX1VTRVJfSU5QVVQnLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuICBpZiAocmFuZ2VTdGFydCA+IHJhbmdlRW5kKSB7XG4gICAgdGhyb3cgbmV3IEdyYXBoUUxFcnJvcihgSW52YWxpZCByYW5nZVN0YXJ0ICgke3JhbmdlU3RlcH0pID4gcmFuZ2VFbmQgKCR7cmFuZ2VFbmR9KWAsIHtcbiAgICAgIGV4dGVuc2lvbnM6IHtcbiAgICAgICAgY29kZTogJ0JBRF9VU0VSX0lOUFVUJyxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbiAgaWYgKGJpbkNvdW50IDw9IDApIHtcbiAgICB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKGBJbnZhbGlkIGJpbkNvdW50ICR7YmluQ291bnR9YCwge1xuICAgICAgZXh0ZW5zaW9uczoge1xuICAgICAgICBjb2RlOiAnQkFEX1VTRVJfSU5QVVQnLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIHJhbmdlU3RlcCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGJpbkNvdW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBHcmFwaFFMRXJyb3IoJ0ludmFsaWQgdG8gc2V0IFwicmFuZ2VTdGVwXCIgYW5kIFwiYmluQ291bnRcIiBhdCBzYW1lIHRpbWUnLCB7XG4gICAgICBleHRlbnNpb25zOiB7XG4gICAgICAgIGNvZGU6ICdCQURfVVNFUl9JTlBVVCcsXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2YgcmFuZ2VTdGVwICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudW1lcmljSGlzdG9ncmFtV2l0aEZpeGVkUmFuZ2VTdGVwKFxuICAgICAge1xuICAgICAgICBlc0luc3RhbmNlLFxuICAgICAgICBlc0luZGV4LFxuICAgICAgICBlc1R5cGUsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBlc0luZGV4LFxuICAgICAgICBlc1R5cGUsXG4gICAgICAgIGZpbHRlcixcbiAgICAgICAgZmllbGQsXG4gICAgICAgIHJhbmdlU3RhcnQsXG4gICAgICAgIHJhbmdlRW5kLFxuICAgICAgICByYW5nZVN0ZXAsXG4gICAgICAgIGZpbHRlclNlbGYsXG4gICAgICAgIGRlZmF1bHRBdXRoRmlsdGVyLFxuICAgICAgICBuZXN0ZWRBZ2dGaWVsZHMsXG4gICAgICAgIG5lc3RlZFBhdGgsXG4gICAgICB9LFxuICAgICk7XG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5Db3VudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVtZXJpY0hpc3RvZ3JhbVdpdGhGaXhlZEJpbkNvdW50KFxuICAgICAge1xuICAgICAgICBlc0luc3RhbmNlLFxuICAgICAgICBlc0luZGV4LFxuICAgICAgICBlc1R5cGUsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBmaWx0ZXIsXG4gICAgICAgIGZpZWxkLFxuICAgICAgICByYW5nZVN0YXJ0LFxuICAgICAgICByYW5nZUVuZCxcbiAgICAgICAgYmluQ291bnQsXG4gICAgICAgIGZpbHRlclNlbGYsXG4gICAgICAgIGRlZmF1bHRBdXRoRmlsdGVyLFxuICAgICAgICBuZXN0ZWRBZ2dGaWVsZHMsXG4gICAgICAgIG5lc3RlZFBhdGgsXG4gICAgICB9LFxuICAgICk7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbnVtZXJpY0dsb2JhbFN0YXRzKFxuICAgIHtcbiAgICAgIGVzSW5zdGFuY2UsXG4gICAgICBlc0luZGV4LFxuICAgICAgZXNUeXBlLFxuICAgIH0sXG4gICAge1xuICAgICAgZmlsdGVyLFxuICAgICAgZmllbGQsXG4gICAgICByYW5nZVN0YXJ0LFxuICAgICAgcmFuZ2VFbmQsXG4gICAgICBmaWx0ZXJTZWxmLFxuICAgICAgZGVmYXVsdEF1dGhGaWx0ZXIsXG4gICAgICBuZXN0ZWRBZ2dGaWVsZHMsXG4gICAgICBuZXN0ZWRQYXRoLFxuICAgIH0sXG4gICk7XG4gIHJldHVybiBbcmVzdWx0XTtcbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIGFnZ3JlZ2F0aW9uIGZvciB0ZXh0IGZpZWxkLCBhbmQgcmV0dXJucyBoaXN0b2dyYW1cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbTAgLSBzb21lIEVTIHJlbGF0ZWQgYXJndW1lbnRzOiBlc0luc3RhbmNlLCBlc0luZGV4LCBhbmQgZXNUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW0xIC0gc29tZSBncmFwaHFsIHJlbGF0ZWQgYXJndW1lbnRzXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW0xLmZpbHRlciAtIGZpbHRlciAoaWYgYW55KSB0byBhcHBseSBvbiBhZ2dyZWdhdGlvblxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtMS5maWVsZCAtIGZpZWxkIHRvIGFnZ3JlZ2F0ZS4gUmVxdWlyZWRcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbTEuZmlsdGVyU2VsZiAtIG9ubHkgdmFsaWQgaWYgdG8gYXZvaWQgZmlsdGVyaW5nIHRoZSBzYW1lIGFnZ3JlZ2F0aW9uIGZpZWxkXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW0xLmRlZmF1bHRBdXRoRmlsdGVyIC0gb25jZSBwYXJhbTEuZmlsdGVyIGlzIGVtcHR5LFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZSB0aGlzIGF1dGggcmVsYXRlZCBmaWx0ZXIgaW5zdGVhZFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtMS5uZXN0ZWRBZ2dGaWVsZHMgLSBmaWVsZHMgZm9yIHN1Yi1hZ2dyZWdhdGlvbnNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRlcm1zIGFuZC9vciBtaXNzaW5nIGFnZ3JlZ2F0aW9uKVxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtMS5uZXN0ZWRQYXRoIC0gcGF0aCBpbmZvIHVzZWQgYnkgbmVzdGVkIGFnZ3JlZ2F0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB0ZXh0QWdncmVnYXRpb24gPSBhc3luYyAoXG4gIHtcbiAgICBlc0luc3RhbmNlLFxuICAgIGVzSW5kZXgsXG4gICAgZXNUeXBlLFxuICB9LFxuICB7XG4gICAgZmlsdGVyLFxuICAgIGZpZWxkLFxuICAgIGZpbHRlclNlbGYsXG4gICAgZGVmYXVsdEF1dGhGaWx0ZXIsXG4gICAgbmVzdGVkQWdnRmllbGRzLFxuICAgIG5lc3RlZFBhdGgsXG4gICAgaXNOdW1lcmljRmllbGQsXG4gIH0sXG4pID0+IHtcbiAgY29uc3QgcXVlcnlCb2R5ID0geyBzaXplOiAwIH07XG4gIGlmICghIWZpbHRlciB8fCAhIWRlZmF1bHRBdXRoRmlsdGVyKSB7XG4gICAgcXVlcnlCb2R5LnF1ZXJ5ID0gZ2V0RmlsdGVyT2JqKFxuICAgICAgZXNJbnN0YW5jZSxcbiAgICAgIGVzSW5kZXgsXG4gICAgICBmaWx0ZXIsXG4gICAgICBmaWVsZCxcbiAgICAgIGZpbHRlclNlbGYsXG4gICAgICBkZWZhdWx0QXV0aEZpbHRlcixcbiAgICApO1xuICB9XG5cbiAgbGV0IG1pc3NpbmdBbGlhcyA9IHt9O1xuICAvLyBkb24ndCBhZGQgbWlzc2luZyBhbGlhcyB0byBudW1lcmljIGZpZWxkIGJ5IGRlZmF1bHRcbiAgLy8gc2luY2UgdGhlIHZhbHVlIG9mIG1pc3NpbmcgYWxpYXMgaXMgYSBzdHJpbmdcbiAgaWYgKGNvbmZpZy5lc0NvbmZpZy5hZ2dyZWdhdGlvbkluY2x1ZGVNaXNzaW5nRGF0YSAmJiAhaXNOdW1lcmljRmllbGQpIHtcbiAgICBtaXNzaW5nQWxpYXMgPSB7IG1pc3NpbmdfYnVja2V0OiB0cnVlLCBvcmRlcjogJ2Rlc2MnIH07XG4gIH1cbiAgY29uc3QgYWdnc05hbWUgPSBgJHtmaWVsZH1BZ2dzYDtcbiAgY29uc3QgYWdnc09iaiA9IHt9O1xuICBsZXQgYWdnc05lc3RlZE5hbWU7XG4gIGxldCBmaWVsZE5lc3RlZE5hbWU7XG4gIGlmIChuZXN0ZWRQYXRoKSB7XG4gICAgYWdnc05lc3RlZE5hbWUgPSBgJHtmaWVsZH1OZXN0ZWRBZ2dzYDtcbiAgICBmaWVsZE5lc3RlZE5hbWUgPSBgJHtuZXN0ZWRQYXRofS4ke2ZpZWxkfWA7XG4gIH1cblxuICBpZiAobmVzdGVkQWdnRmllbGRzICYmIG5lc3RlZEFnZ0ZpZWxkcy50ZXJtc0ZpZWxkcykge1xuICAgIG1pc3NpbmdBbGlhcyA9IHt9O1xuICAgIGFnZ3NPYmouYWdncyA9IHVwZGF0ZUFnZ09iamVjdEZvclRlcm1zRmllbGRzKG5lc3RlZEFnZ0ZpZWxkcy50ZXJtc0ZpZWxkcywgYWdnc09iai5hZ2dzKTtcbiAgfVxuXG4gIGlmIChuZXN0ZWRBZ2dGaWVsZHMgJiYgbmVzdGVkQWdnRmllbGRzLm1pc3NpbmdGaWVsZHMpIHtcbiAgICBtaXNzaW5nQWxpYXMgPSB7fTtcbiAgICBhZ2dzT2JqLmFnZ3MgPSB1cGRhdGVBZ2dPYmplY3RGb3JNaXNzaW5nRmllbGRzKG5lc3RlZEFnZ0ZpZWxkcy5taXNzaW5nRmllbGRzLCBhZ2dzT2JqLmFnZ3MpO1xuICB9XG5cbiAgLy8gYnVpbGQgdXAgRVMgcXVlcnkgaWYgaXMgbmVzdGVkIGFnZ3JlZ2F0aW9uXG4gIGlmIChhZ2dzTmVzdGVkTmFtZSkge1xuICAgIHF1ZXJ5Qm9keS5hZ2dzID0ge1xuICAgICAgW2FnZ3NOZXN0ZWROYW1lXToge1xuICAgICAgICBuZXN0ZWQ6IHtcbiAgICAgICAgICBwYXRoOiBuZXN0ZWRQYXRoLFxuICAgICAgICB9LFxuICAgICAgICBhZ2dzOiB7XG4gICAgICAgICAgW2FnZ3NOYW1lXToge1xuICAgICAgICAgICAgY29tcG9zaXRlOiB7XG4gICAgICAgICAgICAgIHNvdXJjZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBbZmllbGROZXN0ZWROYW1lXToge1xuICAgICAgICAgICAgICAgICAgICB0ZXJtczoge1xuICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZE5lc3RlZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgLi4ubWlzc2luZ0FsaWFzLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBzaXplOiBQQUdFX1NJWkUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4uYWdnc09iaixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHF1ZXJ5Qm9keS5hZ2dzID0ge1xuICAgICAgW2FnZ3NOYW1lXToge1xuICAgICAgICBjb21wb3NpdGU6IHtcbiAgICAgICAgICBzb3VyY2VzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIFtmaWVsZF06IHtcbiAgICAgICAgICAgICAgICB0ZXJtczoge1xuICAgICAgICAgICAgICAgICAgZmllbGQsXG4gICAgICAgICAgICAgICAgICAuLi5taXNzaW5nQWxpYXMsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgICBzaXplOiBQQUdFX1NJWkUsXG4gICAgICAgIH0sXG4gICAgICAgIC4uLmFnZ3NPYmosXG4gICAgICB9LFxuICAgIH07XG4gIH1cbiAgbGV0IHJlc3VsdFNpemU7XG4gIGxldCBmaW5hbFJlc3VsdHMgPSBbXTtcbiAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgZG8ge1xuICAgIC8vIHBhcnNlIEVTIHF1ZXJ5IHJlc3VsdCBiYXNlZCBvbiB3aGV0aGVyIGlzIGRvaW5nIG5lc3RlZCBhZ2dyZWdhdGlvbiBvciBub3QgKGlmIGBhZ2dzTmVzdGVkTmFtZWAgaXMgZGVmaW5lZClcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBlc0luc3RhbmNlLnF1ZXJ5KGVzSW5kZXgsIGVzVHlwZSwgcXVlcnlCb2R5KTtcbiAgICByZXN1bHRTaXplID0gMDtcblxuICAgIGNvbnN0IHJlc3VsdEJ1Y2tldHMgPSAoYWdnc05lc3RlZE5hbWUpID8gcmVzdWx0LmFnZ3JlZ2F0aW9uc1thZ2dzTmVzdGVkTmFtZV1bYWdnc05hbWVdLmJ1Y2tldHMgOiByZXN1bHQuYWdncmVnYXRpb25zW2FnZ3NOYW1lXS5idWNrZXRzO1xuICAgIHJlc3VsdEJ1Y2tldHMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0T2JqID0gcHJvY2Vzc1Jlc3VsdHNGb3JOZXN0ZWRBZ2cgKG5lc3RlZEFnZ0ZpZWxkcywgaXRlbSwge30pXG4gICAgICBmaW5hbFJlc3VsdHMucHVzaCh7XG4gICAgICAgIGtleTogKGZpZWxkTmVzdGVkTmFtZSk/IGl0ZW0ua2V5W2ZpZWxkTmVzdGVkTmFtZV0gOiBpdGVtLmtleVtmaWVsZF0sXG4gICAgICAgIGNvdW50OiBpdGVtLmRvY19jb3VudCxcbiAgICAgICAgLi4ucmVzdWx0T2JqXG4gICAgICB9KTtcbiAgICAgIHJlc3VsdFNpemUgKz0gMTtcbiAgICB9KTtcbiAgICBjb25zdCBhZnRlcktleSA9IChhZ2dzTmVzdGVkTmFtZSkgPyByZXN1bHQuYWdncmVnYXRpb25zW2FnZ3NOZXN0ZWROYW1lXVthZ2dzTmFtZV0uYWZ0ZXJfa2V5IDogcmVzdWx0LmFnZ3JlZ2F0aW9uc1thZ2dzTmFtZV0uYWZ0ZXJfa2V5O1xuICAgIGlmICh0eXBlb2YgYWZ0ZXJLZXkgPT09ICd1bmRlZmluZWQnKSBicmVhaztcbiAgICAoYWdnc05lc3RlZE5hbWUpID8gcXVlcnlCb2R5LmFnZ3NbYWdnc05lc3RlZE5hbWVdLmFnZ3NbYWdnc05hbWVdLmNvbXBvc2l0ZS5hZnRlciA9IGFmdGVyS2V5IDogcXVlcnlCb2R5LmFnZ3NbYWdnc05hbWVdLmNvbXBvc2l0ZS5hZnRlciA9IGFmdGVyS2V5O1xuICB9IHdoaWxlIChyZXN1bHRTaXplID09PSBQQUdFX1NJWkUpO1xuICAvKiBlc2xpbnQtZW5hYmxlICovXG5cbiAgLy8gb3JkZXIgYWdncmVnYXRpb25zIGJ5IGRvYyBjb3VudFxuICBmaW5hbFJlc3VsdHMgPSBmaW5hbFJlc3VsdHMuc29ydCgoZTEsIGUyKSA9PiB7XG4gICAgaWYgKGUxLmtleSA9PT0gbnVsbCkgcmV0dXJuIDE7XG4gICAgaWYgKGUyLmtleSA9PT0gbnVsbCkgcmV0dXJuIC0xO1xuICAgIHJldHVybiBlMi5jb3VudCAtIGUxLmNvdW50O1xuICB9KTtcblxuICAvLyBtYWtlIHRoZSBtaXNzaW5nIGRhdGEgYnVja2V0IHRvIHRoZSBib3R0b20gb2YgdGhlIGxpc3RcbiAgY29uc3QgbGFzdEluZGV4ID0gZmluYWxSZXN1bHRzLmxlbmd0aCAtIDE7XG4gIGlmIChjb25maWcuZXNDb25maWcuYWdncmVnYXRpb25JbmNsdWRlTWlzc2luZ0RhdGEpIHtcbiAgICBjb25zdCBtaXNzaW5nRGF0YUl0ZW0gPSBmaW5hbFJlc3VsdHNbbGFzdEluZGV4XTtcbiAgICBpZiAobWlzc2luZ0RhdGFJdGVtICE9PSB1bmRlZmluZWQgJiYgbWlzc2luZ0RhdGFJdGVtLmtleSA9PT0gbnVsbCkge1xuICAgICAgbWlzc2luZ0RhdGFJdGVtLmtleSA9IGNvbmZpZy5lc0NvbmZpZy5taXNzaW5nRGF0YUFsaWFzO1xuICAgICAgZmluYWxSZXN1bHRzW2xhc3RJbmRleF0gPSBtaXNzaW5nRGF0YUl0ZW07XG4gICAgfVxuICB9XG4gIHJldHVybiBmaW5hbFJlc3VsdHM7XG59O1xuIl0sIm1hcHBpbmdzIjoib1NBQUEsSUFBQUEsUUFBQSxHQUFBQyxPQUFBO0FBQ0EsSUFBQUMsT0FBQSxHQUFBQyxzQkFBQSxDQUFBRixPQUFBO0FBQ0EsSUFBQUcsTUFBQSxHQUFBSCxPQUFBOzs7Ozs7QUFNQSxJQUFBSSxPQUFBLEdBQUFGLHNCQUFBLENBQUFGLE9BQUEsZUFBK0IsU0FBQUUsdUJBQUFHLENBQUEsVUFBQUEsQ0FBQSxJQUFBQSxDQUFBLENBQUFDLFVBQUEsR0FBQUQsQ0FBQSxLQUFBRSxPQUFBLEVBQUFGLENBQUE7O0FBRS9CLE1BQU1HLFNBQVMsR0FBRyxLQUFLOztBQUV2QixNQUFNQyw2QkFBNkIsR0FBR0EsQ0FBQ0MsV0FBVyxFQUFFQyxPQUFPLEtBQUs7RUFDOUQsTUFBTUMsVUFBVSxHQUFHLEVBQUUsR0FBR0QsT0FBTyxDQUFDLENBQUM7RUFDakNELFdBQVcsQ0FBQ0csT0FBTyxDQUFDLENBQUNDLE9BQU8sS0FBSztJQUMvQixNQUFNQyxZQUFZLEdBQUcsR0FBR0QsT0FBTyxPQUFPO0lBQ3RDRixVQUFVLENBQUNHLFlBQVksQ0FBQyxHQUFHO01BQ3pCQyxLQUFLLEVBQUU7UUFDTEMsS0FBSyxFQUFFSCxPQUFPO1FBQ2RJLElBQUksRUFBRVY7TUFDUjtJQUNGLENBQUM7RUFDSCxDQUFDLENBQUM7RUFDRixPQUFPSSxVQUFVO0FBQ25CLENBQUM7O0FBRUQsTUFBTU8sK0JBQStCLEdBQUdBLENBQUNDLGFBQWEsRUFBRVQsT0FBTyxLQUFLO0VBQ2xFLE1BQU1DLFVBQVUsR0FBRyxFQUFFLEdBQUdELE9BQU8sQ0FBQyxDQUFDO0VBQ2pDUyxhQUFhLENBQUNQLE9BQU8sQ0FBQyxDQUFDQyxPQUFPLEtBQUs7SUFDakMsTUFBTUMs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QUMsQ0FBQztJQUNGLE1BQU1DLFFBQVEsR0FBSUwsY0FBYyxHQUFJaEMsTUFBTSxDQUFDRSxZQUFZLENBQUM4QixjQUFjLENBQUMsQ0FBQ0QsUUFBUSxDQUFDLENBQUNPLFNBQVMsR0FBR3RDLE1BQU0sQ0FBQ0UsWUFBWSxDQUFDNkIsUUFBUSxDQUFDLENBQUNPLFNBQVM7SUFDckksSUFBSSxPQUFPRCxRQUFRLEtBQUssV0FBVyxFQUFFO0lBQ3BDTCxjQUFjLEdBQUl6QyxTQUFTLENBQUNLLElBQUksQ0FBQ29DLGNBQWMsQ0FBQyxDQUFDcEMsSUFBSSxDQUFDbUMsUUFBUSxDQUFDLENBQUNHLFNBQVMsQ0FBQ0ssS0FBSyxHQUFHRixRQUFRLEdBQUc5QyxTQUFTLENBQUNLLElBQUksQ0FBQ21DLFFBQVEsQ0FBQyxDQUFDRyxTQUFTLENBQUNLLEtBQUssR0FBR0YsUUFBUTtFQUNuSixDQUFDLFFBQVFELFVBQVUsS0FBSzlGLFNBQVM7RUFDakM7O0VBRUE7RUFDQXNFLFlBQVksR0FBR0EsWUFBWSxDQUFDNEIsSUFBSSxDQUFDLENBQUNDLEVBQUUsRUFBRUMsRUFBRSxLQUFLO0lBQzNDLElBQUlELEVBQUUsQ0FBQ3hFLEdBQUcsS0FBSyxJQUFJLEVBQUUsT0FBTyxDQUFDO0lBQzdCLElBQUl5RSxFQUFFLENBQUN6RSxHQUFHLEtBQUssSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzlCLE9BQU95RSxFQUFFLENBQUNoRixLQUFLLEdBQUcrRSxFQUFFLENBQUMvRSxLQUFLO0VBQzVCLENBQUMsQ0FBQzs7RUFFRjtFQUNBLE1BQU1pRixTQUFTLEdBQUcvQixZQUFZLENBQUM3QyxNQUFNLEdBQUcsQ0FBQztFQUN6QyxJQUFJMkQsZUFBTSxDQUFDQyxRQUFRLENBQUNDLDZCQUE2QixFQUFFO0lBQ2pELE1BQU1nQixlQUFlLEdBQUdoQyxZQUFZLENBQUMrQixTQUFTLENBQUM7SUFDL0MsSUFBSUMsZUFBZSxLQUFLQyxTQUFTLElBQUlELGVBQWUsQ0FBQzNFLEdBQUcsS0FBSyxJQUFJLEVBQUU7TUFDakUyRSxlQUFlLENBQUMzRSxHQUFHLEdBQUd5RCxlQUFNLENBQUNDLFFBQVEsQ0FBQ21CLGdCQUFnQjtNQUN0RGxDLFlBQVksQ0FBQytCLFNBQVMsQ0FBQyxHQUFHQyxlQUFlO0lBQzNDO0VBQ0Y7RUFDQSxPQUFPaEMsWUFBWTtBQUNyQixDQUFDLENBQUM5QixPQUFBLENBQUF5QyxlQUFBLEdBQUFBLGVBQUEiLCJpZ25vcmVMaXN0IjpbXX0=