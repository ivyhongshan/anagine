{"version":3,"file":"connectedFilter-stories.865e38be41fa472fdd38.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAKA;AAOA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;AChZA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACxMA;AACA;AACA;AACA;AAQA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;AC/YA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACdA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;ACxCA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxNA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;;;;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;AASA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://anagine/./src/components/ConnectedFilter/index.jsx","webpack://anagine/./src/components/ConnectedFilter/utils.js","webpack://anagine/./src/components/GuppyWrapper/index.jsx","webpack://anagine/./src/components/Utils/const.js","webpack://anagine/./src/components/Utils/conversion.js","webpack://anagine/./src/components/Utils/filters.js","webpack://anagine/./src/components/Utils/queries.js"],"sourcesContent":["/* eslint react/forbid-prop-types: 0 */\nimport _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport FilterGroup from '@gen3/ui-component/dist/components/filters/FilterGroup';\nimport FilterList from '@gen3/ui-component/dist/components/filters/FilterList';\nimport {\n  getFilterSections,\n  excludeSelfFilterFromAggsData,\n} from './utils';\nimport { ENUM_ACCESSIBILITY } from '../Utils/const';\nimport {\n  askGuppyAboutArrayTypes,\n  askGuppyForAggregationData,\n  getAllFieldsFromFilterConfigs,\n} from '../Utils/queries';\nimport {\n  mergeFilters,\n  updateCountsInInitialTabsOptions,\n  sortTabsOptions,\n  mergeTabOptions,\n  buildFilterStatusForURLFilter,\n} from '../Utils/filters';\n\nclass ConnectedFilter extends React.Component {\n  constructor(props) {\n    super(props);\n\n    const filterConfigsFields = getAllFieldsFromFilterConfigs(props.filterConfig.tabs);\n    const filterConfigsRegularAggFields = filterConfigsFields.fields || [];\n    const filterConfigsAsTextAggFields = filterConfigsFields.asTextAggFields || [];\n    const allRegularAggFields = props.accessibleFieldCheckList\n      ? _.union(filterConfigsRegularAggFields, props.accessibleFieldCheckList)\n      : filterConfigsRegularAggFields;\n    // props.extraAggsFields are chart fields, use asTextAgg for all of them\n    const allAsTextAggFields = _.union(filterConfigsAsTextAggFields, this.props.extraAggsFields);\n\n    this.initialTabsOptions = {};\n    let initialFilter = this.props.adminAppliedPreFilters;\n    let filterStatusArray = [];\n    let filtersApplied = {};\n    if (this.props.userFilterFromURL && Object.keys(this.props.userFilterFromURL).length > 0) {\n      filterStatusArray = buildFilterStatusForURLFilter(\n        this.props.userFilterFromURL,\n        this.getTabsWithSearchFields(),\n      );\n      filtersApplied = this.props.userFilterFromURL;\n      initialFilter = mergeFilters(this.props.userFilterFromURL, this.props.adminAppliedPreFilters);\n    }\n\n    this.state = {\n      allRegularAggFields,\n      allAsTextAggFields,\n      initialAggsData: {},\n      receivedAggsData: {},\n      accessibility: ENUM_ACCESSIBILITY.ALL,\n      adminAppliedPreFilters: { ...this.props.adminAppliedPreFilters },\n      filter: { ...initialFilter },\n      filtersApplied,\n      filterStatusArray,\n    };\n    this.filterGroupRef = React.createRef();\n    this.adminPreFiltersFrozen = JSON.stringify(this.props.adminAppliedPreFilters).slice();\n    this.arrayFields = [];\n  }\n\n  componentDidMount() {\n    if (this.props.onUpdateAccessLevel) {\n      this.props.onUpdateAccessLevel(this.state.accessibility);\n    }\n    if (this.props.onFilterChange) {\n      this.props.onFilterChange(this.state.adminAppliedPreFilters, this.state.accessibility);\n    }\n    askGuppyForAggregationData(\n      this.props.guppyConfig.path,\n      this.props.guppyConfig.type,\n      this.state.allRegularAggFields,\n      this.state.allAsTextAggFields,\n      this.state.filter,\n      this.state.accessibility,\n      this.props.csrfToken,\n    )\n      .then((res) => {\n        if (!res.data) {\n          const msg = `error querying guppy${res.errors && res.errors.length > 0 ? `: ${res.errors[0].message}` : ''}`;\n          console.error(msg); // eslint-disable-line no-console\n        }\n        this.handleReceiveNewAggsData(\n          res.data._aggregation[this.props.guppyConfig.type],\n          this.state.adminAppliedPreFilters,\n        );\n        this.saveInitialAggsData(res.data._aggregation[this.props.guppyConfig.type]);\n      });\n\n    askGuppyAboutArrayTypes(this.props.guppyConfig.path).then((res) => {\n      this.arrayFields = [];\n      const keys = Object.keys(res);\n\n      for (let i = 0; i < keys.length; i += 1) {\n        if (res[keys[i]].arrayFields && res[keys[i]].arrayFields.length > 0) {\n          this.arrayFields = this.arrayFields.concat(res[keys[i]].arrayFields);\n        }\n      }\n    });\n  }\n\n  handleReceiveNewAggsData(receivedAggsData, filterResults) {\n    this.setState({ receivedAggsData });\n    if (this.props.onReceiveNewAggsData) {\n      const resultAggsData = excludeSelfFilterFromAggsData(receivedAggsData, filterResults);\n      this.props.onReceiveNewAggsData(resultAggsData);\n    }\n  }\n\n  /**\n   * Handler function that is called every time filter changes\n   * What this function does:\n   * 1. Ask guppy for aggregation data using (processed) filter\n   * 2. After get aggregation response, call `handleReceiveNewAggsData` handler\n   *    to process new received agg data\n   * 3. If there's `onFilterChange` callback function from parent, call it\n   * @param {object} filterResults\n   */\n  handleFilterChange(filterResults) {\n    this.setState({ adminAppliedPreFilters: JSON.parse(this.adminPreFiltersFrozen) });\n    const mergedFilterResults = mergeFilters(filterResults, JSON.parse(this.adminPreFiltersFrozen));\n\n    const newFilterStatusArray = buildFilterStatusForURLFilter(\n      mergedFilterResults,\n      this.getTabsWithSearchFields(),\n    );\n\n    this.setState({ filtersApplied: mergedFilterResults, filterStatusArray: newFilterStatusArray });\n    askGuppyForAggregationData(\n      this.props.guppyConfig.path,\n      this.props.guppyConfig.type,\n      this.state.allRegularAggFields,\n      this.state.allAsTextAggFields,\n      mergedFilterResults,\n      this.state.accessibility,\n      this.props.csrfToken,\n    )\n      .then((res) => {\n        this.handleReceiveNewAggsData(\n          res.data._aggregation[this.props.guppyConfig.type],\n          mergedFilterResults,\n        );\n      });\n\n    if (this.props.onFilterChange) {\n      this.props.onFilterChange(mergedFilterResults, this.state.accessibility);\n    }\n  }\n\n  getTabsWithSearchFields() {\n    const newTabs = this.props.filterConfig.tabs.map(({\n      title, fields, searchFields, asTextAggFields = [],\n    }) => {\n      if (searchFields) {\n        return { title, fields: searchFields.concat(fields).concat(asTextAggFields) };\n      }\n      return { title, fields: fields.concat(asTextAggFields) };\n    });\n    return newTabs;\n  }\n\n  // eslint-disable-next-line react/no-unused-class-component-methods\n  setFilter(filter) {\n    if (this.filterGroupRef.current) {\n      this.filterGroupRef.current.resetFilter();\n    }\n    this.handleFilterChange(filter);\n  }\n\n  /**\n   * This function contains partial rendering logic for filter components.\n   * It transfers aggregation data (`this.state.receivedAggsData`) to items inside filters.\n   * But before that, the function first calls `this.props.onProcessFilterAggsData`, which is\n   * a callback function passed by `ConnectedFilter`'s parent component, so that the parent\n   * component could do some pre-processing modification about filter.\n   */\n  getFilterTabs() {\n    const filtersToDisplay = this.state.filtersApplied;\n    if (this.props.hidden) return null;\n    let processedTabsOptions = this.props.onProcessFilterAggsData(this.state.receivedAggsData);\n\n    // Get filter values\n    const allFilterValues = this.props.filterConfig.tabs.reduce(\n      (accumulator, tab) => ([...accumulator, ...tab.fields, ...tab.asTextAggFields || []]),\n      [],\n    );\n\n    if (Object.keys(this.initialTabsOptions).length === 0) {\n      this.initialTabsOptions = processedTabsOptions;\n    }\n\n    processedTabsOptions = updateCountsInInitialTabsOptions(\n      this.initialTabsOptions,\n      processedTabsOptions,\n      filtersToDisplay,\n      // for tiered access filters\n      this.props.tierAccessLimit ? this.props.accessibleFieldCheckList : [],\n      allFilterValues,\n    );\n\n    if (Object.keys(filtersToDisplay).length) {\n      // if has applied filters, sort tab options as selected/unselected separately\n      const selectedTabsOptions = {};\n      const unselectedTabsOptions = {};\n      Object.keys(processedTabsOptions).forEach((opt) => {\n        if (!processedTabsOptions[`${opt}`].histogram.length) {\n          if (!unselectedTabsOptions[`${opt}`]) {\n            unselectedTabsOptions[`${opt}`] = {};\n          }\n          unselectedTabsOptions[`${opt}`].histogram = [];\n          return;\n        }\n        processedTabsOptions[`${opt}`].histogram.forEach((entry) => {\n          if (filtersToDisplay[`${opt}`]\n          && filtersToDisplay[`${opt}`].selectedValues\n          && filtersToDisplay[`${opt}`].selectedValues.includes(entry.key)) {\n            if (!selectedTabsOptions[`${opt}`]) {\n              selectedTabsOptions[`${opt}`] = {};\n            }\n            if (!selectedTabsOptions[`${opt}`].histogram) {\n              selectedTabsOptions[`${opt}`].histogram = [];\n            }\n            selectedTabsOptions[`${opt}`].histogram.push({ key: entry.key, count: entry.count });\n          } else {\n            if (!unselectedTabsOptions[`${opt}`]) {\n              unselectedTabsOptions[`${opt}`] = {};\n            }\n            if (typeof (entry.key) !== 'string') { // if it is a range filter, just copy and return\n              unselectedTabsOptions[`${opt}`].histogram = processedTabsOptions[`${opt}`].histogram;\n              return;\n            }\n            if (!unselectedTabsOptions[`${opt}`].histogram) {\n              unselectedTabsOptions[`${opt}`].histogram = [];\n            }\n            unselectedTabsOptions[`${opt}`].histogram.push({ key: entry.key, count: entry.count });\n          }\n        });\n      });\n\n      // For search filters: If there are any search filters present, include\n      // the selected options in the `selectedTabsOptions` array.\n      // ------\n      let allSearchFields = [];\n      this.props.filterConfig.tabs.forEach((tab) => {\n        allSearchFields = allSearchFields.concat(tab.searchFields);\n      });\n      allSearchFields.forEach((field) => {\n        if (filtersToDisplay[`${field}`]) {\n          const { selectedValues } = filtersToDisplay[`${field}`];\n          if (selectedValues) {\n            filtersToDisplay[`${field}`].selectedValues.forEach((val) => {\n              if (!selectedTabsOptions[`${field}`]) {\n                selectedTabsOptions[`${field}`] = {};\n              }\n              if (!selectedTabsOptions[`${field}`].histogram) {\n                selectedTabsOptions[`${field}`].histogram = [];\n              }\n              selectedTabsOptions[`${field}`].histogram.push({ key: val });\n            });\n          }\n        }\n      });\n      // -------\n      processedTabsOptions = mergeTabOptions(\n        sortTabsOptions(selectedTabsOptions),\n        sortTabsOptions(unselectedTabsOptions),\n      );\n    } else {\n      processedTabsOptions = sortTabsOptions(processedTabsOptions);\n    }\n    if (!processedTabsOptions || Object.keys(processedTabsOptions).length === 0) return null;\n    const { fieldMapping } = this.props;\n    const tabs = this.props.filterConfig.tabs.map(({ fields, searchFields, asTextAggFields = [] }, index) => {\n      const aggFields = _.union(fields, asTextAggFields);\n      const sections = getFilterSections(\n        aggFields,\n        searchFields,\n        fieldMapping,\n        processedTabsOptions,\n        this.state.initialAggsData,\n        this.state.adminAppliedPreFilters,\n        this.props.guppyConfig,\n        this.arrayFields,\n        this.props.filterValuesToHide,\n        this.props.csrfToken,\n      );\n      const filterStatus = this.state.filterStatusArray\n        ? this.state.filterStatusArray[index] : null;\n      return (\n        <FilterList\n          key={index}\n          sections={sections}\n          hideEmptyFilterSection={this.props.hideEmptyFilterSection}\n          tierAccessLimit={this.props.tierAccessLimit}\n          lockedTooltipMessage={this.props.lockedTooltipMessage}\n          disabledTooltipMessage={this.props.disabledTooltipMessage}\n          arrayFields={this.arrayFields}\n          filterStatusFromParent={filterStatus}\n        />\n      );\n    });\n    return tabs;\n  }\n\n  /**\n   * Save initial aggregation data, especially for range slider\n   * so that we still have min/max values for range slider\n   * @param {object} aggsData\n   */\n  saveInitialAggsData(aggsData) {\n    this.setState({ initialAggsData: aggsData });\n  }\n\n  render() {\n    if (this.props.hidden) return null;\n    const filterTabs = this.getFilterTabs();\n    if (!filterTabs || filterTabs.length === 0) {\n      return null;\n    }\n    // If there are any search fields, insert them at the top of each tab's fields.\n    const filterConfig = {\n      tabs: this.getTabsWithSearchFields(),\n    };\n    return (\n      <FilterGroup\n        ref={this.filterGroupRef}\n        className={this.props.className}\n        tabs={filterTabs}\n        filterConfig={filterConfig}\n        onFilterChange={(e) => this.handleFilterChange(e)}\n        hideZero={this.props.hideZero}\n        filterStatusFromParent={this.state.filterStatusArray}\n        filterResultsFromParent={this.state.filtersApplied}\n      />\n    );\n  }\n}\n\nConnectedFilter.propTypes = {\n  filterConfig: PropTypes.shape({\n    tabs: PropTypes.arrayOf(PropTypes.shape({\n      title: PropTypes.string,\n      fields: PropTypes.arrayOf(PropTypes.string),\n      asTextAggFields: PropTypes.arrayOf(PropTypes.string),\n      searchFields: PropTypes.arrayOf(PropTypes.string),\n    })),\n  }).isRequired,\n  extraAggsFields: PropTypes.arrayOf(PropTypes.string),\n  guppyConfig: PropTypes.shape({\n    path: PropTypes.string.isRequired,\n    type: PropTypes.string.isRequired,\n  }).isRequired,\n  onFilterChange: PropTypes.func,\n  onReceiveNewAggsData: PropTypes.func,\n  className: PropTypes.string,\n  fieldMapping: PropTypes.arrayOf(PropTypes.shape({\n    field: PropTypes.string,\n    name: PropTypes.string,\n  })),\n  tierAccessLimit: PropTypes.number,\n  onProcessFilterAggsData: PropTypes.func,\n  onUpdateAccessLevel: PropTypes.func,\n  adminAppliedPreFilters: PropTypes.object,\n  lockedTooltipMessage: PropTypes.string,\n  disabledTooltipMessage: PropTypes.string,\n  accessibleFieldCheckList: PropTypes.arrayOf(PropTypes.string),\n  hideZero: PropTypes.bool,\n  hidden: PropTypes.bool,\n  userFilterFromURL: PropTypes.object,\n  hideEmptyFilterSection: PropTypes.bool,\n  filterValuesToHide: PropTypes.arrayOf(PropTypes.string),\n  csrfToken: PropTypes.string,\n};\n\nConnectedFilter.defaultProps = {\n  extraAggsFields: [],\n  onFilterChange: () => {},\n  onReceiveNewAggsData: () => {},\n  className: '',\n  fieldMapping: [],\n  tierAccessLimit: undefined,\n  onProcessFilterAggsData: (data) => (data),\n  onUpdateAccessLevel: () => {},\n  adminAppliedPreFilters: {},\n  lockedTooltipMessage: '',\n  disabledTooltipMessage: '',\n  accessibleFieldCheckList: undefined,\n  hideZero: false,\n  hidden: false,\n  userFilterFromURL: {},\n  hideEmptyFilterSection: false,\n  filterValuesToHide: [],\n  csrfToken: '',\n};\n\nexport default ConnectedFilter;\n","import flat from 'flat';\nimport { queryGuppyForRawDataAndTotalCounts } from '../Utils/queries';\n\nconst getSingleFilterOption = (histogramResult, initHistogramRes, filterValuesToHide) => {\n  if (!histogramResult || !histogramResult.histogram) {\n    throw new Error(`Error parsing field options ${JSON.stringify(histogramResult)}`);\n  }\n  // if this is for range slider\n  if (histogramResult.histogram.length === 1 && (typeof histogramResult.histogram[0].key) !== 'string') {\n    const rangeOptions = histogramResult.histogram.map((item) => {\n      const minValue = initHistogramRes ? initHistogramRes.histogram[0].key[0] : item.key[0];\n      const maxValue = initHistogramRes ? initHistogramRes.histogram[0].key[1] : item.key[1];\n      return {\n        filterType: 'range',\n        min: Math.floor(minValue),\n        max: Math.ceil(maxValue),\n        lowerBound: item.key[0],\n        upperBound: item.key[1],\n        count: item.count,\n      };\n    });\n    return rangeOptions;\n  }\n  let rawTextOptions = histogramResult.histogram;\n  // hide filterValuesToHide from filters\n  // filterValuesToHide added to guppyConfig in data-portal\n  if (filterValuesToHide.length > 0) {\n    rawTextOptions = histogramResult.histogram\n      .filter((item) => filterValuesToHide.indexOf(item.key) < 0);\n  }\n  const textOptions = rawTextOptions.map((item) => ({\n    text: item.key,\n    filterType: 'singleSelect',\n    count: item.count,\n    accessible: item.accessible,\n  }));\n  return textOptions;\n};\n\nconst capitalizeFirstLetter = (str) => {\n  const res = str.replace(/_|\\./gi, ' ');\n  return res.replace(/\\w\\S*/g, (txt) => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase());\n};\n\n// createSearchFilterLoadOptionsFn creates a handler function that loads the search filter's\n// autosuggest options as the user types in the search filter.\nconst createSearchFilterLoadOptionsFn = (field, guppyConfig) => (searchString, offset) => {\n  const NUM_SEARCH_OPTIONS = 20;\n  return new Promise((resolve, reject) => {\n    // If searchString is empty return just the first NUM_SEARCH_OPTIONS options.\n    // This allows the client to show default options in the search filter before\n    // the user has started searching.\n    let filter = {};\n    if (searchString) {\n      filter = {\n        search: {\n          keyword: searchString,\n          fields: [field],\n        },\n      };\n    }\n    queryGuppyForRawDataAndTotalCounts(\n      guppyConfig.path,\n      guppyConfig.type,\n      [field],\n      filter,\n      undefined,\n      undefined,\n      offset,\n      NUM_SEARCH_OPTIONS,\n      'accessible',\n    )\n      .then((res) => {\n        if (!res.data || !res.data[guppyConfig.type]) {\n          resolve({\n            options: [],\n            hasMore: false,\n          });\n        } else {\n          const results = res.data[guppyConfig.type];\n          const totalCount = res.data._aggregation[guppyConfig.type]._totalCount;\n          resolve({\n            options: results.map((result) => ({ value: result[field], label: result[field] })),\n            hasMore: totalCount > offset + results.length,\n          });\n        }\n      }).catch((err) => {\n        reject(err);\n      });\n  });\n};\n\nexport const checkIsArrayField = (field, arrayFields) => {\n  let isArrayField = false;\n  const keys = Object.keys(arrayFields);\n  for (let i = 0; i < keys.length; i += 1) {\n    if (arrayFields[keys[i]].includes(field)) {\n      isArrayField = true;\n    }\n  }\n  return isArrayField;\n};\n\nexport const getFilterSections = (\n  aggFields,\n  searchFields,\n  fieldMapping,\n  tabsOptions,\n  initialTabsOptions,\n  adminAppliedPreFilters,\n  guppyConfig,\n  arrayFields,\n  filterValuesToHide,\n  csrfToken,\n) => {\n  let searchFieldSections = [];\n\n  if (searchFields) {\n    // Process searchFields first -- searchFields are special filters that allow the user\n    // to search over all options, instead of displaying all options in a list. This allows\n    // guppy/portal to support filters that have too many options to be displayed in a list.\n    searchFieldSections = searchFields.map((field) => {\n      const overrideName = fieldMapping.find((entry) => (entry.field === field));\n      const label = overrideName ? overrideName.name : capitalizeFirstLetter(field);\n\n      const tabsOptionsFiltered = { ...tabsOptions[field] };\n      if (Object.keys(adminAppliedPreFilters).includes(field)) {\n        tabsOptionsFiltered.histogram = tabsOptionsFiltered.histogram.filter(\n          (x) => adminAppliedPreFilters[field].selectedValues.includes(x.key),\n        );\n      }\n\n      // For searchFields, don't pass all options to the component, only the selected ones.\n      // This allows selected options to appear below the search box once they are selected.\n      let selectedOptions = [];\n      if (tabsOptionsFiltered && tabsOptionsFiltered.histogram) {\n        selectedOptions = getSingleFilterOption(\n          tabsOptionsFiltered,\n          initialTabsOptions ? initialTabsOptions[field] : undefined,\n          filterValuesToHide,\n        );\n      }\n\n      return {\n        title: label,\n        options: selectedOptions,\n        isSearchFilter: true,\n        onSearchFilterLoadOptions: createSearchFilterLoadOptionsFn(field, guppyConfig, csrfToken),\n      };\n    });\n  }\n\n  const sections = aggFields.map((field) => {\n    const overrideName = fieldMapping.find((entry) => (entry.field === field));\n    const label = overrideName ? overrideName.name : capitalizeFirstLetter(field);\n\n    const tabsOptionsFiltered = { ...tabsOptions[field] };\n    if (Object.keys(adminAppliedPreFilters).includes(field)) {\n      tabsOptionsFiltered.histogram = tabsOptionsFiltered.histogram.filter(\n        (x) => adminAppliedPreFilters[field].selectedValues.includes(x.key),\n      );\n    }\n\n    const defaultOptions = getSingleFilterOption(\n      tabsOptionsFiltered,\n      initialTabsOptions ? initialTabsOptions[field] : undefined,\n      filterValuesToHide,\n    );\n\n    const fieldIsArrayField = checkIsArrayField(field, arrayFields);\n\n    return {\n      title: label,\n      options: defaultOptions,\n      isArrayField: fieldIsArrayField,\n    };\n  });\n  return searchFieldSections.concat(sections);\n};\n\nexport const excludeSelfFilterFromAggsData = (receivedAggsData, filterResults) => {\n  if (!filterResults) return receivedAggsData;\n  const resultAggsData = {};\n  const flattenAggsData = flat(receivedAggsData, { safe: true });\n  Object.keys(flattenAggsData).forEach((field) => {\n    const actualFieldName = field.replace('.histogram', '').replace('.asTextHistogram', '');\n    const histogram = flattenAggsData[`${field}`];\n    if (!histogram) return;\n    if (actualFieldName in filterResults) {\n      let resultHistogram = [];\n      if (typeof filterResults[`${actualFieldName}`].selectedValues !== 'undefined') {\n        const { selectedValues } = filterResults[`${actualFieldName}`];\n        resultHistogram = histogram.filter((bucket) => selectedValues.includes(bucket.key));\n      }\n      resultAggsData[`${actualFieldName}`] = { histogram: resultHistogram };\n    } else {\n      resultAggsData[`${actualFieldName}`] = { histogram: flattenAggsData[`${field}`] };\n    }\n  });\n  return resultAggsData;\n};\n","/* eslint-disable react/jsx-fragments */\n/* eslint react/forbid-prop-types: 0 */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  askGuppyForRawData,\n  downloadDataFromGuppy,\n  askGuppyForTotalCounts,\n  getAllFieldsFromGuppy,\n  getAccessibleResources,\n  askGuppyForSubAggregationData,\n} from '../Utils/queries';\nimport { ENUM_ACCESSIBILITY, FILE_FORMATS } from '../Utils/const';\nimport { mergeFilters } from '../Utils/filters';\n\n/**\n * Wrapper that connects to Guppy server,\n * and pass filter, aggs, and data to children components\n * Input props:\n *   - filterConfig: configuration for ConnectedFilter component\n *   - guppyConfig: Guppy server config\n *   - onFilterChange: callback that takes filter as argument, will be\n * called every time filter changes\n *   - onReceiveNewAggsData: callback that takes aggregation results\n * as argument, will be called every time aggregation results updated\n *\n * This wrapper will pass following data (filters, aggs, configs) to children components via prop:\n *   - aggsData: the aggregation results, format:\n *         {\n *             // for text aggregation\n *            [field]: { histogram: [{key: 'v1', count: 42}, {key: 'v2', count: 19}, ...] },\n *             // for numeric aggregation\n *            [field]: { histogram: [{key: [1, 83], count: 100}] },\n *            ...\n *         }\n *   - filter: the filters, format:\n *         {\n *            [field]: { selectedValues: ['v1', 'v2', ...] },  // for text filter\n *            [field]: { upperBound: 1, lowerBound: 83 },  // for range filter\n *            ...\n *         }\n *   - filterConfig: configuration for ConnectedFilter component\n *   - rawData: raw data records filtered (with offset, size, and sort applied)\n *   - totalCount: total count of raw data records\n *\n */\nclass GuppyWrapper extends React.Component {\n  constructor(props) {\n    super(props);\n    let initialFilter = this.props.adminAppliedPreFilters;\n    if (Object.keys(this.props.initialFilterFromURL).length > 0) {\n      initialFilter = mergeFilters(\n        this.props.initialFilterFromURL,\n        this.props.adminAppliedPreFilters,\n      );\n    }\n    // to avoid asynchronizations, we store another filter as private var\n    this.filter = { ...initialFilter };\n    this.adminPreFiltersFrozen = JSON.stringify(this.props.adminAppliedPreFilters).slice();\n    this.state = {\n      gettingDataFromGuppy: false,\n      aggsData: {},\n      filter: { ...initialFilter },\n      rawData: [],\n      totalCount: 0,\n      allRegularAggFields: [],\n      allAsTextAggFields: [],\n      rawDataFields: [],\n      accessibleFieldObject: undefined,\n      unaccessibleFieldObject: undefined,\n      accessibility: ENUM_ACCESSIBILITY.ALL,\n      adminAppliedPreFilters: { ...this.props.adminAppliedPreFilters },\n      userFilterFromURL: { ...this.props.initialFilterFromURL },\n    };\n  }\n\n  componentDidMount() {\n    getAllFieldsFromGuppy(\n      this.props.guppyConfig.path,\n      this.props.guppyConfig.type,\n      this.props.csrfToken,\n    ).then((fields) => {\n      const rawDataFields = (this.props.rawDataFields && this.props.rawDataFields.length > 0)\n        ? this.props.rawDataFields : fields;\n      this.setState({\n        allRegularAggFields: fields,\n        rawDataFields,\n      }, () => {\n        this.getDataFromGuppy(this.state.rawDataFields, undefined, true);\n      });\n    });\n    if (typeof this.props.accessibleFieldCheckList !== 'undefined') {\n      getAccessibleResources(\n        this.props.guppyConfig.path,\n        this.props.guppyConfig.type,\n        this.props.accessibleFieldCheckList,\n        this.props.csrfToken,\n      ).then(({ accessibleFieldObject, unaccessibleFieldObject }) => {\n        this.setState({\n          accessibleFieldObject,\n          unaccessibleFieldObject,\n        });\n      });\n    }\n  }\n\n  handleReceiveNewAggsData(aggsData) {\n    if (this.props.onReceiveNewAggsData) {\n      this.props.onReceiveNewAggsData(aggsData, this.filter);\n    }\n    this.setState({ aggsData });\n  }\n\n  handleFilterChange(userFilterFromUserInput, accessibility) {\n    let userFilter = userFilterFromUserInput;\n\n    // Apply user filters from URL on page load. Empty out state to avoid reapplying used filters.\n    if (Object.keys(userFilter).length === 0\n      && Object.keys(this.state.userFilterFromURL).length > 0) {\n      userFilter = JSON.parse(JSON.stringify(this.state.userFilterFromURL));\n      this.setState({ userFilterFromURL: {} });\n    }\n\n    this.setState({ adminAppliedPreFilters: JSON.parse(this.adminPreFiltersFrozen) });\n    let filter = { ...userFilter };\n    if (Object.keys(this.state.adminAppliedPreFilters).length > 0) {\n      filter = mergeFilters(userFilter, this.state.adminAppliedPreFilters);\n    }\n    if (this.props.onFilterChange) {\n      this.props.onFilterChange(filter);\n    }\n    this.filter = filter;\n    this.setState({\n      filter,\n      accessibility,\n    }, () => {\n      this.getDataFromGuppy(this.state.rawDataFields, undefined, true);\n    });\n  }\n\n  /**\n   * Fetch data from Guppy server.\n   * This function will update this.state.rawData and this.state.totalCount\n   */\n  handleFetchAndUpdateRawData({ offset = 0, size = 20, sort = [] }) {\n    return this.getDataFromGuppy(this.state.rawDataFields, sort, true, offset, size);\n  }\n\n  /**\n   * Download all data from Guppy server and return raw data\n   * This function uses current filter argument\n   */\n  handleDownloadRawData({ sort, format }) {\n    // error handling for misconfigured format types\n    if (format && !(format.toUpperCase() in FILE_FORMATS)) {\n      // eslint-disable-next-line no-console\n      console.error(`Invalid value ${format} found for arg format!`);\n    }\n    return downloadDataFromGuppy(\n      this.props.guppyConfig.path,\n      this.props.guppyConfig.type,\n      this.state.totalCount,\n      {\n        fields: this.state.rawDataFields,\n        sort: sort || [],\n        filter: this.state.filter,\n        accessibility: this.state.accessibility,\n        format,\n      },\n      this.props.csrfToken,\n    );\n  }\n\n  /**\n   * Download all data from Guppy server and return raw data\n   * For only given fields\n   * This function uses current filter argument\n   */\n  handleDownloadRawDataByFields({ fields, sort = [] }) {\n    let targetFields = fields;\n    if (typeof fields === 'undefined') {\n      targetFields = this.state.rawDataFields;\n    }\n    return downloadDataFromGuppy(\n      this.props.guppyConfig.path,\n      this.props.guppyConfig.type,\n      this.state.totalCount,\n      {\n        fields: targetFields,\n        sort,\n        filter: this.state.filter,\n        accessibility: this.state.accessibility,\n      },\n      this.props.csrfToken,\n    );\n  }\n\n  /**\n   * Get total count from other es type, with filter\n   * @param {string} type\n   * @param {object} filter\n   */\n  handleAskGuppyForTotalCounts(type, filter) {\n    return askGuppyForTotalCounts(\n      this.props.guppyConfig.path,\n      type,\n      filter,\n      this.state.accessibility,\n      this.props.csrfToken,\n    );\n  }\n\n  /**\n   * Get raw data from other es type, with filter\n   * @param {string} type\n   * @param {object} filter\n   * @param {string[]} fields\n   */\n  handleDownloadRawDataByTypeAndFilter(type, filter, fields) {\n    return askGuppyForTotalCounts(\n      this.props.guppyConfig.path,\n      type,\n      filter,\n      this.state.accessibility,\n      this.props.csrfToken,\n    )\n      .then((count) => downloadDataFromGuppy(\n        this.props.guppyConfig.path,\n        type,\n        count,\n        {\n          fields,\n          filter,\n        },\n        this.props.csrfToken,\n      ));\n  }\n\n  handleAccessLevelUpdate(accessLevel) {\n    this.setState({ accessibility: accessLevel });\n  }\n\n  /**\n   * This function get data with current filter (if any),\n   * and update this.state.rawData and this.state.totalCount\n   * @param {string[]} fields\n   * @param {object} sort\n   * @param {bool} updateDataWhenReceive\n   * @param {number} offset\n   * @param {number} size\n   */\n  getDataFromGuppy(fields, sort, updateDataWhenReceive, offset, size) {\n    this.setState({ gettingDataFromGuppy: true });\n    if (!fields || fields.length === 0) {\n      this.setState({ gettingDataFromGuppy: false });\n      return Promise.resolve({ data: [], totalCount: 0 });\n    }\n\n    // sub aggregations -- for DAT\n    if (this.props.guppyConfig.mainField) {\n      const numericAggregation = this.props.guppyConfig.mainFieldIsNumeric;\n      return askGuppyForSubAggregationData(\n        this.props.guppyConfig.path,\n        this.props.guppyConfig.type,\n        this.props.guppyConfig.mainField,\n        numericAggregation,\n        this.props.guppyConfig.aggFields,\n        [],\n        this.filter,\n        this.state.accessibility,\n        this.props.csrfToken,\n      ).then((res) => {\n        if (!res || !res.data) {\n          throw new Error(`Error getting raw ${this.props.guppyConfig.type} data from Guppy server ${this.props.guppyConfig.path}.`);\n        }\n        const data = res.data._aggregation[this.props.guppyConfig.type];\n        const field = numericAggregation ? 'asTextHistogram' : 'histogram';\n        const parsedData = data[this.props.guppyConfig.mainField][field];\n        if (updateDataWhenReceive) {\n          this.setState({\n            rawData: parsedData,\n          });\n        }\n        this.setState({ gettingDataFromGuppy: false });\n        return {\n          data: res.data,\n        };\n      });\n    }\n\n    // non-nested aggregation\n    return askGuppyForRawData(\n      this.props.guppyConfig.path,\n      this.props.guppyConfig.type,\n      fields,\n      this.filter,\n      sort,\n      undefined,\n      offset,\n      size,\n      this.state.accessibility,\n      this.props.csrfToken,\n    ).then((res) => {\n      if (!res || !res.data) {\n        throw new Error(`Error getting raw ${this.props.guppyConfig.type} data from Guppy server ${this.props.guppyConfig.path}.`);\n      }\n      const parsedData = res.data[this.props.guppyConfig.type];\n      const totalCount = res.data._aggregation[this.props.guppyConfig.type]._totalCount;\n      if (updateDataWhenReceive) {\n        this.setState({\n          rawData: parsedData,\n          totalCount,\n        });\n      }\n      this.setState({ gettingDataFromGuppy: false });\n      return {\n        data: parsedData,\n        totalCount,\n      };\n    });\n  }\n\n  render() {\n    return (\n      <>\n        {\n          React.Children.map(this.props.children, (child) => React.cloneElement(child, {\n            // pass data to children\n            aggsData: this.state.aggsData,\n            aggsDataIsLoading: this.state.gettingDataFromGuppy,\n            filter: this.state.filter,\n            filterConfig: this.props.filterConfig,\n            rawData: this.state.rawData, // raw data (with current filter applied)\n            totalCount: this.state.totalCount, // total count of raw data (current filter applied)\n            fetchAndUpdateRawData: this.handleFetchAndUpdateRawData.bind(this),\n            downloadRawData: this.handleDownloadRawData.bind(this),\n            downloadRawDataByFields: this.handleDownloadRawDataByFields.bind(this),\n            allRegularAggFields: this.state.allRegularAggFields,\n            allAsTextAggFields: this.state.allAsTextAggFields,\n            accessibleFieldObject: this.state.accessibleFieldObject,\n            unaccessibleFieldObject: this.state.unaccessibleFieldObject,\n\n            // a callback function which return total counts for any type, with any filter\n            getTotalCountsByTypeAndFilter: this.handleAskGuppyForTotalCounts.bind(this),\n            downloadRawDataByTypeAndFilter: this.handleDownloadRawDataByTypeAndFilter.bind(this),\n\n            // below are just for ConnectedFilter component\n            onReceiveNewAggsData: this.handleReceiveNewAggsData.bind(this),\n            onFilterChange: this.handleFilterChange.bind(this),\n            guppyConfig: this.props.guppyConfig,\n            onUpdateAccessLevel: this.handleAccessLevelUpdate.bind(this),\n            adminAppliedPreFilters: this.props.adminAppliedPreFilters,\n            accessibleFieldCheckList: this.props.accessibleFieldCheckList,\n            csrfToken: this.props.csrfToken,\n          }))\n        }\n      </>\n    );\n  }\n}\n\nGuppyWrapper.propTypes = {\n  guppyConfig: PropTypes.shape({\n    path: PropTypes.string,\n    type: PropTypes.string,\n    mainField: PropTypes.string,\n    mainFieldIsNumeric: PropTypes.bool,\n    aggFields: PropTypes.array,\n  }).isRequired,\n  children: PropTypes.oneOfType([\n    PropTypes.arrayOf(PropTypes.node),\n    PropTypes.node,\n  ]).isRequired,\n  filterConfig: PropTypes.shape({\n    tabs: PropTypes.arrayOf(PropTypes.shape({\n      title: PropTypes.string,\n      fields: PropTypes.arrayOf(PropTypes.string),\n      searchFields: PropTypes.arrayOf(PropTypes.string),\n    })),\n  }).isRequired,\n  rawDataFields: PropTypes.arrayOf(PropTypes.string),\n  onReceiveNewAggsData: PropTypes.func,\n  onFilterChange: PropTypes.func,\n  accessibleFieldCheckList: PropTypes.arrayOf(PropTypes.string),\n  adminAppliedPreFilters: PropTypes.object,\n  initialFilterFromURL: PropTypes.object,\n  csrfToken: PropTypes.string,\n};\n\nGuppyWrapper.defaultProps = {\n  onReceiveNewAggsData: () => {},\n  onFilterChange: () => {},\n  rawDataFields: [],\n  accessibleFieldCheckList: undefined,\n  adminAppliedPreFilters: {},\n  initialFilterFromURL: {},\n  csrfToken: '',\n};\n\nexport default GuppyWrapper;\n","export const ENUM_ACCESSIBILITY = {\n  ACCESSIBLE: 'accessible',\n  UNACCESSIBLE: 'unaccessible',\n  ALL: 'all',\n};\n\nexport const FILE_FORMATS = {\n  JSON: 'json',\n  TSV: 'tsv',\n  CSV: 'csv',\n};\n\nexport const FILE_DELIMITERS = {\n  tsv: '\\t',\n  csv: ',',\n};\n","import { FILE_DELIMITERS } from './const';\n\nconst papaparse = require('papaparse');\nconst flatten = require('flat');\n\n/**\n * Flattens a deep nested JSON object skipping\n * the first level to avoid potentially flattening\n * non-nested data.\n * @param {JSON} json\n */\nexport async function flattenJson(json) {\n  const flattenedJson = [];\n  Object.keys(json).forEach((key) => {\n    flattenedJson.push(flatten(json[key], { delimiter: '_' }));\n  });\n  return flattenedJson;\n}\n\n/**\n * Converts JSON based on a config.\n * @param {JSON} json\n * @param {Object} config\n */\nexport async function conversion(json, config) {\n  return papaparse.unparse(json, config);\n}\n\n/**\n * Converts JSON to a specified file format.\n * Defaultes to JSON if file format is not supported.\n * @param {JSON} json\n * @param {string} format\n */\nexport async function jsonToFormat(json, format) {\n  if (format in FILE_DELIMITERS) {\n    const flatJson = await flattenJson(json);\n    const data = await conversion(flatJson, { delimiter: FILE_DELIMITERS[format] });\n    return data;\n  }\n  return json;\n}\n","import flat from 'flat';\nimport _ from 'lodash';\n\n/**\n   * This function takes two objects containing filters to be applied\n   * and combines them into one filter object in the same format.\n   * Note: the admin filter takes precedence. Selected values in the user\n   * filter will be discarded if the key collides. This is to avoid\n   * the user undoing the admin filter. (Multiple user checkboxes increase the\n   * amount of data shown when combined, but an admin filter should always decrease\n   * or keep constant the amount of data shown when combined with a user filter).\n  * */\nexport const mergeFilters = (userFilter, adminAppliedPreFilter) => {\n  const filterAB = { ...userFilter };\n  Object.keys(adminAppliedPreFilter).forEach((key) => {\n    if (Object.prototype.hasOwnProperty.call(userFilter, key)\n          && Object.prototype.hasOwnProperty.call(adminAppliedPreFilter, key)) {\n      const userFilterSubset = userFilter[key].selectedValues.filter(\n        (x) => adminAppliedPreFilter[key].selectedValues.includes(x),\n      );\n      if (userFilterSubset.length > 0) {\n        // The user-applied filter is more exclusive than the admin-applied filter.\n        filterAB[key].selectedValues = userFilter[key].selectedValues;\n      } else {\n        // The admin-applied filter is more exclusive than the user-applied filter.\n        filterAB[key].selectedValues = adminAppliedPreFilter[key].selectedValues;\n      }\n    } else if (Object.prototype.hasOwnProperty.call(adminAppliedPreFilter, key)) {\n      filterAB[key] = { selectedValues: adminAppliedPreFilter[key].selectedValues };\n    }\n  });\n\n  return filterAB;\n};\n\n/**\n   * This function updates the counts in the initial set of tab options\n   * calculated from unfiltered data.\n   * It is used to retain field options in the rendering if\n   * they are still checked but their counts are zero.\n   */\nexport const updateCountsInInitialTabsOptions = (\n  initialTabsOptions,\n  processedTabsOptions,\n  filtersApplied,\n  accessibleFieldCheckList,\n  allFilterValues,\n) => {\n  const updatedTabsOptions = {};\n  try {\n    // flatten the tab options first\n    // {\n    //   project_id.histogram: ...\n    //   visit.visit_label.histogram: ...\n    // }\n    const flattenInitialTabsOptions = flat(initialTabsOptions, { safe: true });\n    const flattenProcessedTabsOptions = flat(processedTabsOptions, { safe: true });\n    Object.keys(flattenInitialTabsOptions).forEach((field) => {\n      // in flattened tab options, to get actual field name, strip off the last '.histogram' or '.asTextHistogram'\n      const actualFieldName = field.replace('.histogram', '').replace('.asTextHistogram', '');\n\n      // check if Filter Value if not skip\n      if (!allFilterValues.includes(actualFieldName)) {\n        return;\n      }\n\n      // possible to have '.' in actualFieldName, so use it as a string\n      updatedTabsOptions[`${actualFieldName}`] = { histogram: [] };\n      // if in tiered access mode\n      // we need not to process filters for field in accessibleFieldCheckList\n      if (accessibleFieldCheckList\n        && accessibleFieldCheckList.includes(actualFieldName)\n        && flattenProcessedTabsOptions[`${field}`]) {\n        updatedTabsOptions[`${actualFieldName}`].histogram = flattenProcessedTabsOptions[`${field}`];\n        return;\n      }\n      const histogram = flattenInitialTabsOptions[`${field}`];\n      if (!histogram || typeof histogram !== 'object') {\n        console.error(`Guppy did not return histogram data for filter field ${actualFieldName}`); // eslint-disable-line no-console\n        return;\n      }\n      histogram.forEach((opt) => {\n        const { key } = opt;\n        if (typeof (key) !== 'string') { // key is a range, just copy the histogram\n          updatedTabsOptions[`${actualFieldName}`].histogram = flattenInitialTabsOptions[`${field}`];\n          if (flattenProcessedTabsOptions[`${field}`]\n            && flattenProcessedTabsOptions[`${field}`].length > 0\n            && updatedTabsOptions[`${actualFieldName}`].histogram) {\n            const currentFlattenProcessedTabsOptions = flattenProcessedTabsOptions[`${field}`][0];\n\n            // if empty count histogram should be removed so filter is not shown\n            if (currentFlattenProcessedTabsOptions.count === 0) {\n              updatedTabsOptions[`${actualFieldName}`].histogram = [];\n              return;\n            }\n            updatedTabsOptions[`${actualFieldName}`].histogram[0].count = currentFlattenProcessedTabsOptions.count;\n            const newKey = [0, 0];\n            if (currentFlattenProcessedTabsOptions.key[0]) {\n              // because of the prefer-destructuring eslint rule\n              const newLowerBound = currentFlattenProcessedTabsOptions.key[0];\n              newKey[0] = newLowerBound;\n            }\n            if (currentFlattenProcessedTabsOptions.key[1]) {\n              const newHigherBound = currentFlattenProcessedTabsOptions.key[1];\n              newKey[1] = newHigherBound;\n            }\n            updatedTabsOptions[`${actualFieldName}`].histogram[0].key = newKey;\n          }\n          return;\n        }\n        if (flattenProcessedTabsOptions[`${field}`]) {\n          const findOpt = flattenProcessedTabsOptions[`${field}`].find((o) => o.key === key);\n          if (findOpt) {\n            const { count } = findOpt;\n            updatedTabsOptions[`${actualFieldName}`].histogram.push({ key, count });\n          }\n        }\n      });\n      if (filtersApplied[`${actualFieldName}`]) {\n        if (filtersApplied[`${actualFieldName}`].selectedValues) {\n          filtersApplied[`${actualFieldName}`].selectedValues.forEach((optKey) => {\n            if (!updatedTabsOptions[`${actualFieldName}`].histogram.find((o) => o.key === optKey)) {\n              updatedTabsOptions[`${actualFieldName}`].histogram.push({ key: optKey, count: 0 });\n            }\n          });\n        }\n      }\n    });\n  } catch (err) {\n    /* eslint-disable no-console */\n    // hopefully we won't get here but in case of\n    // out-of-index error or obj undefined error\n    console.error('error when processing filter data: ', err);\n    console.trace();\n    /* eslint-enable no-console */\n  }\n  return updatedTabsOptions;\n};\n\nfunction sortCountThenAlpha(a, b) {\n  if (a.count === b.count) {\n    return a.key < b.key ? -1 : 1;\n  }\n  return b.count - a.count;\n}\n\nexport const sortTabsOptions = (tabsOptions) => {\n  const fields = Object.keys(tabsOptions);\n  const sortedTabsOptions = { ...tabsOptions };\n  for (let x = 0; x < fields.length; x += 1) {\n    const field = fields[x];\n\n    const optionsForThisField = sortedTabsOptions[field].histogram;\n    optionsForThisField.sort(sortCountThenAlpha);\n    sortedTabsOptions[field].histogram = optionsForThisField;\n  }\n  return sortedTabsOptions;\n};\n\n/**\n   * This function takes two TabsOptions object and merge them together\n   * The order of merged histogram array is preserved by firstHistogram.concat(secondHistogram)\n   */\nexport const mergeTabOptions = (firstTabsOptions, secondTabsOptions) => {\n  if (!firstTabsOptions || !Object.keys(firstTabsOptions).length) {\n    return secondTabsOptions;\n  }\n  if (!secondTabsOptions || !Object.keys(secondTabsOptions).length) {\n    return firstTabsOptions;\n  }\n\n  const allOptionKeys = _.union(Object.keys(firstTabsOptions), Object.keys(secondTabsOptions));\n  const mergedTabOptions = {};\n  allOptionKeys.forEach((optKey) => {\n    if (!mergedTabOptions[`${optKey}`]) {\n      mergedTabOptions[`${optKey}`] = {};\n    }\n    if (!mergedTabOptions[`${optKey}`].histogram) {\n      mergedTabOptions[`${optKey}`].histogram = [];\n    }\n    const firstHistogram = (firstTabsOptions[`${optKey}`] && firstTabsOptions[`${optKey}`].histogram) ? firstTabsOptions[`${optKey}`].histogram : [];\n    const secondHistogram = (secondTabsOptions[`${optKey}`] && secondTabsOptions[`${optKey}`].histogram) ? secondTabsOptions[`${optKey}`].histogram : [];\n    mergedTabOptions[`${optKey}`].histogram = firstHistogram.concat(secondHistogram);\n  });\n  return mergedTabOptions;\n};\n\nexport const buildFilterStatusForURLFilter = (userFilter, tabs) => {\n  // Converts filter-applied form to filter-displayed form\n  // TODO: add support for search filters\n  const filteringFields = Object.keys(userFilter);\n  const filterStatusArray = tabs.map(() => ([]));\n\n  for (let tabIndex = 0; tabIndex < tabs.length; tabIndex += 1) {\n    const allFieldsForThisTab = _.union(tabs[tabIndex].fields, tabs[tabIndex].asTextAggFields || []);\n    filterStatusArray[tabIndex] = allFieldsForThisTab.map(() => ({}));\n    for (let i = 0; i < filteringFields.length; i += 1) {\n      const sectionIndex = allFieldsForThisTab.indexOf(filteringFields[i]);\n      if (sectionIndex !== -1) {\n        let userFilterSmallForm = {};\n        const filterVar = userFilter[filteringFields[i]];\n        if (typeof filterVar === 'object' && filterVar.selectedValues) {\n          // Single select values:\n          for (let j = 0; j < filterVar.selectedValues.length; j += 1) {\n            userFilterSmallForm[filterVar.selectedValues[j]] = true;\n          }\n        } else if (typeof filterVar === 'object'\n          && (filterVar.lowerBound || filterVar.upperBound)) {\n          // Range values:\n          userFilterSmallForm = [filterVar.lowerBound, filterVar.upperBound];\n        }\n        filterStatusArray[tabIndex][sectionIndex] = userFilterSmallForm;\n      }\n    }\n  }\n\n  return filterStatusArray;\n};\n","import fetch from 'isomorphic-fetch';\nimport { jsonToFormat } from './conversion';\n\nconst graphqlEndpoint = '/graphql';\nconst downloadEndpoint = '/download';\nconst statusEndpoint = '/_status';\nconst headers = {\n  'Content-Type': 'application/json',\n};\n\nconst histogramQueryStrForEachField = (field, isAsTextAgg = false) => {\n  const splittedFieldArray = field.split('.');\n  const splittedField = splittedFieldArray.shift();\n  if (splittedFieldArray.length === 0) {\n    return (`\n    ${splittedField} {\n      ${(isAsTextAgg) ? 'asTextHistogram' : 'histogram'} {\n        key\n        count\n      }\n    }`);\n  }\n  return (`\n  ${splittedField} {\n    ${histogramQueryStrForEachField(splittedFieldArray.join('.'))}\n  }`);\n};\n\nconst queryGuppyForAggs = (path, type, regularAggFields, asTextAggFields, gqlFilter, acc, csrfToken = '') => {\n  let accessibility = acc;\n  if (accessibility !== 'all' && accessibility !== 'accessible' && accessibility !== 'unaccessible') {\n    accessibility = 'all';\n  }\n\n  const queryBody = {};\n  if (gqlFilter) {\n    const queryWithFilter = `query ($filter: JSON) {\n      _aggregation {\n        ${type} (filter: $filter, filterSelf: false, accessibility: ${accessibility}) {\n          ${regularAggFields.map((field) => histogramQueryStrForEachField(field, false))}\n          ${asTextAggFields.map((field) => histogramQueryStrForEachField(field, true))}\n        }\n      }\n    }`;\n    queryBody.variables = { filter: gqlFilter };\n    queryBody.query = queryWithFilter;\n  } else {\n    queryBody.query = `query {\n      _aggregation {\n        ${type} (accessibility: ${accessibility}) {\n          ${regularAggFields.map((field) => histogramQueryStrForEachField(field, false))}\n          ${asTextAggFields.map((field) => histogramQueryStrForEachField(field, true))}\n        }\n      }\n    }`;\n  }\n\n  return fetch(`${path}${graphqlEndpoint}`, {\n    method: 'POST',\n    headers: csrfToken ? { ...headers, 'x-csrf-token': csrfToken } : headers,\n    body: JSON.stringify(queryBody),\n  }).then((response) => response.json());\n};\n\nconst queryGuppyForStatus = (path) => fetch(`${path}${statusEndpoint}`, {\n  method: 'GET',\n  headers,\n}).then((response) => response.json());\n\nconst nestedHistogramQueryStrForEachField = (mainField, numericAggAsText) => (`\n  ${mainField} {\n    ${numericAggAsText ? 'asTextHistogram' : 'histogram'} {\n      key\n      count\n      missingFields {\n        field\n        count\n      }\n      termsFields {\n        field\n        count\n        terms {\n          key\n          count\n        }\n      }\n    }\n  }`);\n\nconst queryGuppyForSubAgg = (\n  path,\n  type,\n  mainField,\n  termsFields,\n  missingFields,\n  gqlFilter,\n  acc,\n  numericAggAsText = false,\n  csrfToken = '',\n) => {\n  let accessibility = acc;\n  if (accessibility !== 'all' && accessibility !== 'accessible' && accessibility !== 'unaccessible') {\n    accessibility = 'all';\n  }\n\n  const nestedAggFields = {};\n  if (termsFields) {\n    nestedAggFields.termsFields = termsFields;\n  }\n  if (missingFields) {\n    nestedAggFields.missingFields = missingFields;\n  }\n\n  const query = `query ($nestedAggFields: JSON) {\n    _aggregation {\n      ${type} (nestedAggFields: $nestedAggFields, accessibility: ${accessibility}) {\n        ${nestedHistogramQueryStrForEachField(mainField, numericAggAsText)}\n      }\n    }\n  }`;\n  const queryBody = { query };\n  queryBody.variables = { nestedAggFields };\n  if (gqlFilter) {\n    const queryWithFilter = `query ($filter: JSON, $nestedAggFields: JSON) {\n      _aggregation {\n        ${type} (filter: $filter, filterSelf: false, nestedAggFields: $nestedAggFields, accessibility: ${accessibility}) {\n          ${nestedHistogramQueryStrForEachField(mainField, numericAggAsText)}\n        }\n      }\n    }`;\n    queryBody.variables = { filter: gqlFilter, nestedAggFields };\n    queryBody.query = queryWithFilter;\n  }\n  return fetch(`${path}${graphqlEndpoint}`, {\n    method: 'POST',\n    headers: csrfToken ? { ...headers, 'x-csrf-token': csrfToken } : headers,\n    body: JSON.stringify(queryBody),\n  }).then((response) => response.json())\n    .catch((err) => {\n      throw new Error(`Error during queryGuppyForSubAgg ${err}`);\n    });\n};\n\nconst rawDataQueryStrForEachField = (field) => {\n  const splittedFieldArray = field.split('.');\n  const splittedField = splittedFieldArray.shift();\n  if (splittedFieldArray.length === 0) {\n    return (`\n    ${splittedField}\n    `);\n  }\n  return (`\n  ${splittedField} {\n    ${rawDataQueryStrForEachField(splittedFieldArray.join('.'))}\n  }`);\n};\n\nexport const queryGuppyForRawDataAndTotalCounts = (\n  path,\n  type,\n  fields,\n  gqlFilter,\n  sort,\n  format,\n  offset = 0,\n  size = 20,\n  accessibility = 'all',\n  csrfToken = '',\n) => {\n  let queryLine = 'query {';\n  if (gqlFilter || sort || format) {\n    queryLine = `query (${sort ? '$sort: JSON,' : ''}${gqlFilter ? '$filter: JSON,' : ''}${format ? '$format: Format' : ''}) {`;\n  }\n  let dataTypeLine = `${type} (accessibility: ${accessibility}, offset: ${offset}, first: ${size}, format: $format) {`;\n  if (gqlFilter || sort || format) {\n    dataTypeLine = `${type} (accessibility: ${accessibility}, offset: ${offset}, first: ${size}, ${format ? 'format: $format, ' : ''}, ${sort ? 'sort: $sort, ' : ''}${gqlFilter ? 'filter: $filter,' : ''}) {`;\n  }\n  let typeAggsLine = `${type} accessibility: ${accessibility} {`;\n  if (gqlFilter) {\n    typeAggsLine = `${type} (filter: $filter, accessibility: ${accessibility}) {`;\n  }\n  const processedFields = fields.map((field) => rawDataQueryStrForEachField(field));\n  const query = `${queryLine}\n    ${dataTypeLine}\n      ${processedFields.join('\\n')}\n    }\n    _aggregation {\n      ${typeAggsLine}\n        _totalCount\n      }\n    }\n  }`;\n  const queryBody = { query };\n  queryBody.variables = {};\n  if (format) queryBody.variables.format = format;\n  if (gqlFilter) queryBody.variables.filter = gqlFilter;\n  if (sort) queryBody.variables.sort = sort;\n  return fetch(`${path}${graphqlEndpoint}`, {\n    method: 'POST',\n    headers: csrfToken ? { ...headers, 'x-csrf-token': csrfToken } : headers,\n    body: JSON.stringify(queryBody),\n  }).then((response) => response.json())\n    .catch((err) => {\n      throw new Error(`Error during queryGuppyForRawDataAndTotalCounts ${err}`);\n    });\n};\n\nexport const getGQLFilter = (filterObj) => {\n  const facetsList = [];\n  Object.keys(filterObj).forEach((field) => {\n    const filterValues = filterObj[field];\n    const fieldSplitted = field.split('.');\n    const fieldName = fieldSplitted[fieldSplitted.length - 1];\n    // The combine mode defaults to OR when not set.\n    const combineMode = filterValues.__combineMode ? filterValues.__combineMode : 'OR';\n\n    const hasSelectedValues = filterValues.selectedValues && filterValues.selectedValues.length > 0;\n    const hasRangeFilter = typeof filterValues.lowerBound !== 'undefined' && typeof filterValues.upperBound !== 'undefined';\n\n    let facetsPiece = {};\n    if (hasSelectedValues && combineMode === 'OR') {\n      facetsPiece = {\n        IN: {\n          [fieldName]: filterValues.selectedValues,\n        },\n      };\n    } else if (hasSelectedValues && combineMode === 'AND') {\n      facetsPiece = { AND: [] };\n      for (let i = 0; i < filterValues.selectedValues.length; i += 1) {\n        facetsPiece.AND.push({\n          IN: {\n            [fieldName]: [filterValues.selectedValues[i]],\n          },\n        });\n      }\n    } else if (hasRangeFilter) {\n      facetsPiece = {\n        AND: [\n          { '>=': { [fieldName]: filterValues.lowerBound } },\n          { '<=': { [fieldName]: filterValues.upperBound } },\n        ],\n      };\n    } else if (filterValues.__combineMode && !hasSelectedValues && !hasRangeFilter) {\n      // This filter only has a combine setting so far. We can ignore it.\n      return;\n    } else if (hasSelectedValues) {\n      // filter has selected values but we don't know how to process it\n      // eslint-disable-next-line no-console\n      console.error(filterValues);\n      throw new Error('Invalid filter object');\n    }\n    if (fieldSplitted.length > 1) { // nested field\n      fieldSplitted.pop();\n      facetsPiece = {\n        nested: {\n          path: fieldSplitted.join('.'), // parent path\n          ...facetsPiece,\n        },\n      };\n    }\n    facetsList.push(facetsPiece);\n  });\n  const gqlFilter = {\n    AND: facetsList,\n  };\n  return gqlFilter;\n};\n\n// eslint-disable-next-line max-len\nexport const askGuppyAboutArrayTypes = (path) => queryGuppyForStatus(path).then((res) => res.indices);\n\nexport const askGuppyForAggregationData = (\n  path,\n  type,\n  regularAggFields,\n  asTextAggFields,\n  filter,\n  accessibility,\n  csrfToken = '',\n) => {\n  const gqlFilter = getGQLFilter(filter);\n  return queryGuppyForAggs(path, type, regularAggFields, asTextAggFields, gqlFilter, accessibility, csrfToken);\n};\n\nexport const askGuppyForSubAggregationData = (\n  path,\n  type,\n  mainField,\n  numericAggAsText,\n  termsNestedFields,\n  missedNestedFields,\n  filter,\n  accessibility,\n  csrfToken,\n) => {\n  const gqlFilter = getGQLFilter(filter);\n  return queryGuppyForSubAgg(\n    path,\n    type,\n    mainField,\n    termsNestedFields,\n    missedNestedFields,\n    gqlFilter,\n    accessibility,\n    numericAggAsText,\n    csrfToken,\n  );\n};\n\nexport const askGuppyForRawData = (\n  path,\n  type,\n  fields,\n  filter,\n  sort,\n  format,\n  offset = 0,\n  size = 20,\n  accessibility = 'all',\n  csrfToken = '',\n) => {\n  const gqlFilter = getGQLFilter(filter);\n  return queryGuppyForRawDataAndTotalCounts(\n    path,\n    type,\n    fields,\n    gqlFilter,\n    sort,\n    format,\n    offset,\n    size,\n    accessibility,\n    csrfToken,\n  );\n};\n\nexport const getAllFieldsFromFilterConfigs = (filterTabConfigs) => filterTabConfigs.reduce((acc, cur) => {\n  Object.keys(cur)\n    .filter((key) => key === 'fields' || key === 'asTextAggFields')\n    .forEach((key) => { acc[key] = acc[key].concat(cur[key], []); });\n  return acc;\n}, { fields: [], asTextAggFields: [] });\n\n/**\n * Download all data from guppy using fields, filter, and sort args.\n * If total count is less than 10000 this will use normal graphql endpoint\n * If greater than 10000, use /download endpoint\n */\nexport const downloadDataFromGuppy = (\n  path,\n  type,\n  totalCount,\n  {\n    fields,\n    filter,\n    sort,\n    accessibility,\n    format,\n  },\n  csrfToken = '',\n) => {\n  const SCROLL_SIZE = 10000;\n  const JSON_FORMAT = (format === 'json' || format === undefined);\n  if (totalCount > SCROLL_SIZE) {\n    const queryBody = { type };\n    if (fields) queryBody.fields = fields;\n    if (filter) queryBody.filter = getGQLFilter(filter);\n    if (sort) queryBody.sort = sort;\n    if (typeof accessibility !== 'undefined') queryBody.accessibility = accessibility;\n    return fetch(`${path}${downloadEndpoint}`, {\n      method: 'POST',\n      headers: csrfToken ? { ...headers, 'x-csrf-token': csrfToken } : headers,\n      body: JSON.stringify(queryBody),\n    })\n      .then((r) => r.json())\n      .then((res) => (JSON_FORMAT ? res : jsonToFormat(res, format)));\n  }\n  return askGuppyForRawData(path, type, fields, filter, sort, format, 0, totalCount, accessibility, csrfToken)\n    .then((res) => {\n      if (res && res.data && res.data[type]) {\n        return JSON_FORMAT ? res.data[type] : jsonToFormat(res.data[type], format);\n      }\n      throw Error('Error downloading data from Guppy');\n    });\n};\n\nexport const askGuppyForTotalCounts = (\n  path,\n  type,\n  filter,\n  accessibility = 'all',\n  csrfToken = '',\n) => {\n  const gqlFilter = getGQLFilter(filter);\n  const queryLine = `query ${gqlFilter ? '($filter: JSON)' : ''}{`;\n  const typeAggsLine = `${type} ${gqlFilter ? '(filter: $filter, ' : '('} accessibility: ${accessibility}) {`;\n  const query = `${queryLine}\n    _aggregation {\n      ${typeAggsLine}\n        _totalCount\n      }\n    }\n  }`;\n  const queryBody = { query };\n  queryBody.variables = {};\n  if (gqlFilter) queryBody.variables.filter = gqlFilter;\n\n  return fetch(`${path}${graphqlEndpoint}`, {\n    method: 'POST',\n    headers: csrfToken ? { ...headers, 'x-csrf-token': csrfToken } : headers,\n    body: JSON.stringify(queryBody),\n  }).then((response) => response.json())\n    .then((response) => {\n      if (response.errors) {\n        throw new Error(`Error during download ${response.errors}`);\n      }\n      return response.data._aggregation[type]._totalCount;\n    })\n    .catch((err) => {\n      throw new Error(`Error during download ${err}`);\n    });\n};\n\nexport const getAllFieldsFromGuppy = (\n  path,\n  type,\n  csrfToken = '',\n) => {\n  const query = `{\n    _mapping {\n      ${type}\n    }\n  }`;\n  const queryBody = { query };\n  return fetch(`${path}${graphqlEndpoint}`, {\n    method: 'POST',\n    headers: csrfToken ? { ...headers, 'x-csrf-token': csrfToken } : headers,\n    body: JSON.stringify(queryBody),\n  }).then((response) => response.json())\n    .then((response) => response.data._mapping[type])\n    .catch((err) => {\n      console.log(err);\n      throw new Error(`Error when getting fields from guppy: ${err}`);\n    });\n};\n\nexport const getAccessibleResources = async (\n  path,\n  type,\n  accessibleFieldCheckList,\n  csrfToken = '',\n) => {\n  const accessiblePromiseList = [];\n  const unaccessiblePromiseList = [];\n  accessibleFieldCheckList.forEach((accessibleField) => {\n    const fetchRequestPromise = (accessible) => {\n      const query = `query {\n        _aggregation {\n          ${type} (accessibility: ${accessible ? 'accessible' : 'unaccessible'}) {\n            ${accessibleField} {\n              histogram {\n                key\n                count\n              }\n            }\n          }\n        }\n      }`;\n      const queryBody = { query };\n\n      return fetch(`${path}${graphqlEndpoint}`, {\n        method: 'POST',\n        headers: csrfToken ? { ...headers, 'x-csrf-token': csrfToken } : headers,\n        body: JSON.stringify(queryBody),\n      })\n        .then((response) => response.json())\n        .then(\n          (response) => ({\n            field: accessibleField,\n            list: (response.data._aggregation[type][accessibleField]\n              .histogram.map((item) => item.key)),\n          }),\n        )\n        .catch((err) => {\n          throw new Error(`Error when getting fields from guppy: ${err}`);\n        });\n    };\n    accessiblePromiseList.push(fetchRequestPromise(true));\n    unaccessiblePromiseList.push(fetchRequestPromise(false));\n  });\n\n  const accessibleFieldObject = {};\n  const accessibleFieldResult = await Promise.all(accessiblePromiseList);\n  accessibleFieldResult.forEach((res) => {\n    accessibleFieldObject[res.field] = res.list;\n  });\n  const unaccessibleFieldObject = {};\n  const unaccessibleFieldResult = await Promise.all(unaccessiblePromiseList);\n  unaccessibleFieldResult.forEach((res) => {\n    unaccessibleFieldObject[res.field] = res.list;\n  });\n  return { accessibleFieldObject, unaccessibleFieldObject };\n};\n"],"names":[],"sourceRoot":""}