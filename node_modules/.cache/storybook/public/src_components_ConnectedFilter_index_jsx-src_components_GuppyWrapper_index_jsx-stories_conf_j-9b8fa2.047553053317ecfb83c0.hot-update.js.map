{"version":3,"file":"src_components_ConnectedFilter_index_jsx-src_components_GuppyWrapper_index_jsx-stories_conf_j-9b8fa2.047553053317ecfb83c0.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;;;;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;AASA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://anagine/./src/components/Utils/queries.js"],"sourcesContent":["import fetch from 'isomorphic-fetch';\nimport { jsonToFormat } from './conversion';\n\nconst graphqlEndpoint = '/graphql';\nconst downloadEndpoint = '/download';\nconst statusEndpoint = '/_status';\nconst headers = {\n  'Content-Type': 'application/json',\n};\n\nconst histogramQueryStrForEachField = (field, isAsTextAgg = false) => {\n  const splittedFieldArray = field.split('.');\n  const splittedField = splittedFieldArray.shift();\n  if (splittedFieldArray.length === 0) {\n    return (`\n    ${splittedField} {\n      ${(isAsTextAgg) ? 'asTextHistogram' : 'histogram'} {\n        key\n        count\n      }\n    }`);\n  }\n  return (`\n  ${splittedField} {\n    ${histogramQueryStrForEachField(splittedFieldArray.join('.'))}\n  }`);\n};\n\nconst queryGuppyForAggs = (path, type, regularAggFields, asTextAggFields, gqlFilter, acc, csrfToken = '') => {\n  let accessibility = acc;\n  if (accessibility !== 'all' && accessibility !== 'accessible' && accessibility !== 'unaccessible') {\n    accessibility = 'all';\n  }\n\n  const queryBody = {};\n  if (gqlFilter) {\n    const queryWithFilter = `query ($filter: JSON) {\n      _aggregation {\n        ${type} (filter: $filter, filterSelf: false, accessibility: ${accessibility}) {\n          ${regularAggFields.map((field) => histogramQueryStrForEachField(field, false))}\n          ${asTextAggFields.map((field) => histogramQueryStrForEachField(field, true))}\n        }\n      }\n    }`;\n    queryBody.variables = { filter: gqlFilter };\n    queryBody.query = queryWithFilter;\n  } else {\n    queryBody.query = `query {\n      _aggregation {\n        ${type} (accessibility: ${accessibility}) {\n          ${regularAggFields.map((field) => histogramQueryStrForEachField(field, false))}\n          ${asTextAggFields.map((field) => histogramQueryStrForEachField(field, true))}\n        }\n      }\n    }`;\n  }\n\n  return fetch(`${path}${graphqlEndpoint}`, {\n    method: 'POST',\n    headers: csrfToken ? { ...headers, 'x-csrf-token': csrfToken } : headers,\n    body: JSON.stringify(queryBody),\n  }).then((response) => response.json());\n};\n\nconst queryGuppyForStatus = (path) => fetch(`${path}${statusEndpoint}`, {\n  method: 'GET',\n  headers,\n}).then((response) => response.json());\n\nconst nestedHistogramQueryStrForEachField = (mainField, numericAggAsText) => (`\n  ${mainField} {\n    ${numericAggAsText ? 'asTextHistogram' : 'histogram'} {\n      key\n      count\n      missingFields {\n        field\n        count\n      }\n      termsFields {\n        field\n        count\n        terms {\n          key\n          count\n        }\n      }\n    }\n  }`);\n\nconst queryGuppyForSubAgg = (\n  path,\n  type,\n  mainField,\n  termsFields,\n  missingFields,\n  gqlFilter,\n  acc,\n  numericAggAsText = false,\n  csrfToken = '',\n) => {\n  let accessibility = acc;\n  if (accessibility !== 'all' && accessibility !== 'accessible' && accessibility !== 'unaccessible') {\n    accessibility = 'all';\n  }\n\n  const nestedAggFields = {};\n  if (termsFields) {\n    nestedAggFields.termsFields = termsFields;\n  }\n  if (missingFields) {\n    nestedAggFields.missingFields = missingFields;\n  }\n\n  const query = `query ($nestedAggFields: JSON) {\n    _aggregation {\n      ${type} (nestedAggFields: $nestedAggFields, accessibility: ${accessibility}) {\n        ${nestedHistogramQueryStrForEachField(mainField, numericAggAsText)}\n      }\n    }\n  }`;\n  const queryBody = { query };\n  queryBody.variables = { nestedAggFields };\n  if (gqlFilter) {\n    const queryWithFilter = `query ($filter: JSON, $nestedAggFields: JSON) {\n      _aggregation {\n        ${type} (filter: $filter, filterSelf: false, nestedAggFields: $nestedAggFields, accessibility: ${accessibility}) {\n          ${nestedHistogramQueryStrForEachField(mainField, numericAggAsText)}\n        }\n      }\n    }`;\n    queryBody.variables = { filter: gqlFilter, nestedAggFields };\n    queryBody.query = queryWithFilter;\n  }\n  return fetch(`${path}${graphqlEndpoint}`, {\n    method: 'POST',\n    headers: csrfToken ? { ...headers, 'x-csrf-token': csrfToken } : headers,\n    body: JSON.stringify(queryBody),\n  }).then((response) => response.json())\n    .catch((err) => {\n      throw new Error(`Error during queryGuppyForSubAgg ${err}`);\n    });\n};\n\nconst rawDataQueryStrForEachField = (field) => {\n  const splittedFieldArray = field.split('.');\n  const splittedField = splittedFieldArray.shift();\n  if (splittedFieldArray.length === 0) {\n    return (`\n    ${splittedField}\n    `);\n  }\n  return (`\n  ${splittedField} {\n    ${rawDataQueryStrForEachField(splittedFieldArray.join('.'))}\n  }`);\n};\n\nexport const queryGuppyForRawDataAndTotalCounts = (\n  path,\n  type,\n  fields,\n  gqlFilter,\n  sort,\n  format,\n  offset = 0,\n  size = 20,\n  accessibility = 'all',\n  csrfToken = '',\n) => {\n  let queryLine = 'query {';\n  if (gqlFilter || sort || format) {\n    queryLine = `query (${sort ? '$sort: JSON,' : ''}${gqlFilter ? '$filter: JSON,' : ''}${format ? '$format: Format' : ''}) {`;\n  }\n  let dataTypeLine = `${type} (accessibility: ${accessibility}, offset: ${offset}, first: ${size}, format: $format) {`;\n  if (gqlFilter || sort || format) {\n    dataTypeLine = `${type} (accessibility: ${accessibility}, offset: ${offset}, first: ${size}, ${format ? 'format: $format, ' : ''}, ${sort ? 'sort: $sort, ' : ''}${gqlFilter ? 'filter: $filter,' : ''}) {`;\n  }\n  let typeAggsLine = `${type} accessibility: ${accessibility} {`;\n  if (gqlFilter) {\n    typeAggsLine = `${type} (filter: $filter, accessibility: ${accessibility}) {`;\n  }\n  const processedFields = fields.map((field) => rawDataQueryStrForEachField(field));\n  const query = `${queryLine}\n    ${dataTypeLine}\n      ${processedFields.join('\\n')}\n    }\n    _aggregation {\n      ${typeAggsLine}\n        _totalCount\n      }\n    }\n  }`;\n  const queryBody = { query };\n  queryBody.variables = {};\n  if (format) queryBody.variables.format = format;\n  if (gqlFilter) queryBody.variables.filter = gqlFilter;\n  if (sort) queryBody.variables.sort = sort;\n  return fetch(`${path}${graphqlEndpoint}`, {\n    method: 'POST',\n    headers: csrfToken ? { ...headers, 'x-csrf-token': csrfToken } : headers,\n    body: JSON.stringify(queryBody),\n  }).then((response) => response.json())\n    .catch((err) => {\n      throw new Error(`Error during queryGuppyForRawDataAndTotalCounts ${err}`);\n    });\n};\n\nexport const getGQLFilter = (filterObj) => {\n  const facetsList = [];\n  Object.keys(filterObj).forEach((field) => {\n    const filterValues = filterObj[field];\n    const fieldSplitted = field.split('.');\n    const fieldName = fieldSplitted[fieldSplitted.length - 1];\n    // The combine mode defaults to OR when not set.\n    const combineMode = filterValues.__combineMode ? filterValues.__combineMode : 'OR';\n\n    const hasSelectedValues = filterValues.selectedValues && filterValues.selectedValues.length > 0;\n    const hasRangeFilter = typeof filterValues.lowerBound !== 'undefined' && typeof filterValues.upperBound !== 'undefined';\n\n    let facetsPiece = {};\n    if (hasSelectedValues && combineMode === 'OR') {\n      facetsPiece = {\n        IN: {\n          [fieldName]: filterValues.selectedValues,\n        },\n      };\n    } else if (hasSelectedValues && combineMode === 'AND') {\n      facetsPiece = { AND: [] };\n      for (let i = 0; i < filterValues.selectedValues.length; i += 1) {\n        facetsPiece.AND.push({\n          IN: {\n            [fieldName]: [filterValues.selectedValues[i]],\n          },\n        });\n      }\n    } else if (hasRangeFilter) {\n      facetsPiece = {\n        AND: [\n          { '>=': { [fieldName]: filterValues.lowerBound } },\n          { '<=': { [fieldName]: filterValues.upperBound } },\n        ],\n      };\n    } else if (filterValues.__combineMode && !hasSelectedValues && !hasRangeFilter) {\n      // This filter only has a combine setting so far. We can ignore it.\n      return;\n    } else if (hasSelectedValues) {\n      // filter has selected values but we don't know how to process it\n      // eslint-disable-next-line no-console\n      console.error(filterValues);\n      throw new Error('Invalid filter object');\n    }\n    if (fieldSplitted.length > 1) { // nested field\n      fieldSplitted.pop();\n      facetsPiece = {\n        nested: {\n          path: fieldSplitted.join('.'), // parent path\n          ...facetsPiece,\n        },\n      };\n    }\n    facetsList.push(facetsPiece);\n  });\n  const gqlFilter = {\n    AND: facetsList,\n  };\n  return gqlFilter;\n};\n\n// eslint-disable-next-line max-len\nexport const askGuppyAboutArrayTypes = (path) => queryGuppyForStatus(path).then((res) => res.indices);\n\nexport const askGuppyForAggregationData = (\n  path,\n  type,\n  regularAggFields,\n  asTextAggFields,\n  filter,\n  accessibility,\n  csrfToken = '',\n) => {\n  const gqlFilter = getGQLFilter(filter);\n  return queryGuppyForAggs(path, type, regularAggFields, asTextAggFields, gqlFilter, accessibility, csrfToken);\n};\n\nexport const askGuppyForSubAggregationData = (\n  path,\n  type,\n  mainField,\n  numericAggAsText,\n  termsNestedFields,\n  missedNestedFields,\n  filter,\n  accessibility,\n  csrfToken,\n) => {\n  const gqlFilter = getGQLFilter(filter);\n  return queryGuppyForSubAgg(\n    path,\n    type,\n    mainField,\n    termsNestedFields,\n    missedNestedFields,\n    gqlFilter,\n    accessibility,\n    numericAggAsText,\n    csrfToken,\n  );\n};\n\nexport const askGuppyForRawData = (\n  path,\n  type,\n  fields,\n  filter,\n  sort,\n  format,\n  offset = 0,\n  size = 20,\n  accessibility = 'all',\n  csrfToken = '',\n) => {\n  const gqlFilter = getGQLFilter(filter);\n  return queryGuppyForRawDataAndTotalCounts(\n    path,\n    type,\n    fields,\n    gqlFilter,\n    sort,\n    format,\n    offset,\n    size,\n    accessibility,\n    csrfToken,\n  );\n};\n\nexport const getAllFieldsFromFilterConfigs = (filterTabConfigs) => filterTabConfigs.reduce((acc, cur) => {\n  Object.keys(cur)\n    .filter((key) => key === 'fields' || key === 'asTextAggFields')\n    .forEach((key) => { acc[key] = acc[key].concat(cur[key], []); });\n  return acc;\n}, { fields: [], asTextAggFields: [] });\n\n/**\n * Download all data from guppy using fields, filter, and sort args.\n * If total count is less than 10000 this will use normal graphql endpoint\n * If greater than 10000, use /download endpoint\n */\nexport const downloadDataFromGuppy = (\n  path,\n  type,\n  totalCount,\n  {\n    fields,\n    filter,\n    sort,\n    accessibility,\n    format,\n  },\n  csrfToken = '',\n) => {\n  const SCROLL_SIZE = 10000;\n  const JSON_FORMAT = (format === 'json' || format === undefined);\n  if (totalCount > SCROLL_SIZE) {\n    const queryBody = { type };\n    if (fields) queryBody.fields = fields;\n    if (filter) queryBody.filter = getGQLFilter(filter);\n    if (sort) queryBody.sort = sort;\n    if (typeof accessibility !== 'undefined') queryBody.accessibility = accessibility;\n    return fetch(`${path}${downloadEndpoint}`, {\n      method: 'POST',\n      headers: csrfToken ? { ...headers, 'x-csrf-token': csrfToken } : headers,\n      body: JSON.stringify(queryBody),\n    })\n      .then((r) => r.json())\n      .then((res) => (JSON_FORMAT ? res : jsonToFormat(res, format)));\n  }\n  return askGuppyForRawData(path, type, fields, filter, sort, format, 0, totalCount, accessibility, csrfToken)\n    .then((res) => {\n      if (res && res.data && res.data[type]) {\n        return JSON_FORMAT ? res.data[type] : jsonToFormat(res.data[type], format);\n      }\n      throw Error('Error downloading data from Guppy');\n    });\n};\n\nexport const askGuppyForTotalCounts = (\n  path,\n  type,\n  filter,\n  accessibility = 'all',\n  csrfToken = '',\n) => {\n  const gqlFilter = getGQLFilter(filter);\n  const queryLine = `query ${gqlFilter ? '($filter: JSON)' : ''}{`;\n  const typeAggsLine = `${type} ${gqlFilter ? '(filter: $filter, ' : '('} accessibility: ${accessibility}) {`;\n  const query = `${queryLine}\n    _aggregation {\n      ${typeAggsLine}\n        _totalCount\n      }\n    }\n  }`;\n  const queryBody = { query };\n  queryBody.variables = {};\n  if (gqlFilter) queryBody.variables.filter = gqlFilter;\n\n  return fetch(`${path}${graphqlEndpoint}`, {\n    method: 'POST',\n    headers: csrfToken ? { ...headers, 'x-csrf-token': csrfToken } : headers,\n    body: JSON.stringify(queryBody),\n  }).then((response) => response.json())\n    .then((response) => {\n      if (response.errors) {\n        throw new Error(`Error during download ${response.errors}`);\n      }\n      return response.data._aggregation[type]._totalCount;\n    })\n    .catch((err) => {\n      throw new Error(`Error during download ${err}`);\n    });\n};\n\nexport const getAllFieldsFromGuppy = (\n  path,\n  type,\n  csrfToken = '',\n) => {\n  const query = `{\n    _mapping {\n      ${type}\n    }\n  }`;\n  const queryBody = { query };\n  console.log('queryBody', queryBody);\n  return fetch(`${path}${graphqlEndpoint}`, {\n    method: 'POST',\n    headers: csrfToken ? { ...headers, 'x-csrf-token': csrfToken } : headers,\n    body: JSON.stringify(queryBody),\n  }).then((response) => response.json())\n    .then((response) => response.data._mapping[type])\n    .catch((err) => {\n      throw new Error(`Error when getting fields from guppy: ${err}`);\n    });\n};\n\nexport const getAccessibleResources = async (\n  path,\n  type,\n  accessibleFieldCheckList,\n  csrfToken = '',\n) => {\n  const accessiblePromiseList = [];\n  const unaccessiblePromiseList = [];\n  accessibleFieldCheckList.forEach((accessibleField) => {\n    const fetchRequestPromise = (accessible) => {\n      const query = `query {\n        _aggregation {\n          ${type} (accessibility: ${accessible ? 'accessible' : 'unaccessible'}) {\n            ${accessibleField} {\n              histogram {\n                key\n                count\n              }\n            }\n          }\n        }\n      }`;\n      const queryBody = { query };\n\n      return fetch(`${path}${graphqlEndpoint}`, {\n        method: 'POST',\n        headers: csrfToken ? { ...headers, 'x-csrf-token': csrfToken } : headers,\n        body: JSON.stringify(queryBody),\n      })\n        .then((response) => response.json())\n        .then(\n          (response) => ({\n            field: accessibleField,\n            list: (response.data._aggregation[type][accessibleField]\n              .histogram.map((item) => item.key)),\n          }),\n        )\n        .catch((err) => {\n          throw new Error(`Error when getting fields from guppy: ${err}`);\n        });\n    };\n    accessiblePromiseList.push(fetchRequestPromise(true));\n    unaccessiblePromiseList.push(fetchRequestPromise(false));\n  });\n\n  const accessibleFieldObject = {};\n  const accessibleFieldResult = await Promise.all(accessiblePromiseList);\n  accessibleFieldResult.forEach((res) => {\n    accessibleFieldObject[res.field] = res.list;\n  });\n  const unaccessibleFieldObject = {};\n  const unaccessibleFieldResult = await Promise.all(unaccessiblePromiseList);\n  unaccessibleFieldResult.forEach((res) => {\n    unaccessibleFieldObject[res.field] = res.list;\n  });\n  return { accessibleFieldObject, unaccessibleFieldObject };\n};\n"],"names":[],"sourceRoot":""}