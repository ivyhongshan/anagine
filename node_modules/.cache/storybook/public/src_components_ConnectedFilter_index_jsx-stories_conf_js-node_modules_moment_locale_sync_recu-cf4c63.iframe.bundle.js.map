{"version":3,"file":"src_components_ConnectedFilter_index_jsx-stories_conf_js-node_modules_moment_locale_sync_recu-cf4c63.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvSA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAKA;AAOA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;AChZA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxMA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACdA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;ACxCA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxNA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;;;;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;AASA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACpfA;AACA;AACA;AACA;AAIA;AAGA;AAEA;AACA;AAMA;AAEA;AACA;AAKA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://anagine/./stories/guppyWrapper.css","webpack://anagine/./node_modules/moment/locale/ sync ^\\.\\/.*$","webpack://anagine/./src/components/ConnectedFilter/index.jsx","webpack://anagine/./src/components/ConnectedFilter/utils.js","webpack://anagine/./src/components/Utils/const.js","webpack://anagine/./src/components/Utils/conversion.js","webpack://anagine/./src/components/Utils/filters.js","webpack://anagine/./src/components/Utils/queries.js","webpack://anagine/./stories/conf.js","webpack://anagine/./stories/guppyWrapper.css?f2f1"],"sourcesContent":["// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.guppy-wrapper {\n  width: 100%;\n  display: flex;\n}\n\n.connected-table-example table > thead > tr > th {\n  background-color: #ebebeb;\n}\n\n.connected-table-example table > tbody > tr:nth-child(even) {\n  background-color: #f2f2f2;\n}\n\n.guppy-wrapper__filter {\n  display: inline;\n  width: 20%;\n}\n\n.guppy-wrapper__table {\n  display: inline;\n  width: 80%;\n}\n`, \"\",{\"version\":3,\"sources\":[\"webpack://./stories/guppyWrapper.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,WAAW;EACX,aAAa;AACf;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,eAAe;EACf,UAAU;AACZ;;AAEA;EACE,eAAe;EACf,UAAU;AACZ\",\"sourcesContent\":[\".guppy-wrapper {\\n  width: 100%;\\n  display: flex;\\n}\\n\\n.connected-table-example table > thead > tr > th {\\n  background-color: #ebebeb;\\n}\\n\\n.connected-table-example table > tbody > tr:nth-child(even) {\\n  background-color: #f2f2f2;\\n}\\n\\n.guppy-wrapper__filter {\\n  display: inline;\\n  width: 20%;\\n}\\n\\n.guppy-wrapper__table {\\n  display: inline;\\n  width: 80%;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","var map = {\n\t\"./af\": \"./node_modules/moment/locale/af.js\",\n\t\"./af.js\": \"./node_modules/moment/locale/af.js\",\n\t\"./ar\": \"./node_modules/moment/locale/ar.js\",\n\t\"./ar-dz\": \"./node_modules/moment/locale/ar-dz.js\",\n\t\"./ar-dz.js\": \"./node_modules/moment/locale/ar-dz.js\",\n\t\"./ar-kw\": \"./node_modules/moment/locale/ar-kw.js\",\n\t\"./ar-kw.js\": \"./node_modules/moment/locale/ar-kw.js\",\n\t\"./ar-ly\": \"./node_modules/moment/locale/ar-ly.js\",\n\t\"./ar-ly.js\": \"./node_modules/moment/locale/ar-ly.js\",\n\t\"./ar-ma\": \"./node_modules/moment/locale/ar-ma.js\",\n\t\"./ar-ma.js\": \"./node_modules/moment/locale/ar-ma.js\",\n\t\"./ar-ps\": \"./node_modules/moment/locale/ar-ps.js\",\n\t\"./ar-ps.js\": \"./node_modules/moment/locale/ar-ps.js\",\n\t\"./ar-sa\": \"./node_modules/moment/locale/ar-sa.js\",\n\t\"./ar-sa.js\": \"./node_modules/moment/locale/ar-sa.js\",\n\t\"./ar-tn\": \"./node_modules/moment/locale/ar-tn.js\",\n\t\"./ar-tn.js\": \"./node_modules/moment/locale/ar-tn.js\",\n\t\"./ar.js\": \"./node_modules/moment/locale/ar.js\",\n\t\"./az\": \"./node_modules/moment/locale/az.js\",\n\t\"./az.js\": \"./node_modules/moment/locale/az.js\",\n\t\"./be\": \"./node_modules/moment/locale/be.js\",\n\t\"./be.js\": \"./node_modules/moment/locale/be.js\",\n\t\"./bg\": \"./node_modules/moment/locale/bg.js\",\n\t\"./bg.js\": \"./node_modules/moment/locale/bg.js\",\n\t\"./bm\": \"./node_modules/moment/locale/bm.js\",\n\t\"./bm.js\": \"./node_modules/moment/locale/bm.js\",\n\t\"./bn\": \"./node_modules/moment/locale/bn.js\",\n\t\"./bn-bd\": \"./node_modules/moment/locale/bn-bd.js\",\n\t\"./bn-bd.js\": \"./node_modules/moment/locale/bn-bd.js\",\n\t\"./bn.js\": \"./node_modules/moment/locale/bn.js\",\n\t\"./bo\": \"./node_modules/moment/locale/bo.js\",\n\t\"./bo.js\": \"./node_modules/moment/locale/bo.js\",\n\t\"./br\": \"./node_modules/moment/locale/br.js\",\n\t\"./br.js\": \"./node_modules/moment/locale/br.js\",\n\t\"./bs\": \"./node_modules/moment/locale/bs.js\",\n\t\"./bs.js\": \"./node_modules/moment/locale/bs.js\",\n\t\"./ca\": \"./node_modules/moment/locale/ca.js\",\n\t\"./ca.js\": \"./node_modules/moment/locale/ca.js\",\n\t\"./cs\": \"./node_modules/moment/locale/cs.js\",\n\t\"./cs.js\": \"./node_modules/moment/locale/cs.js\",\n\t\"./cv\": \"./node_modules/moment/locale/cv.js\",\n\t\"./cv.js\": \"./node_modules/moment/locale/cv.js\",\n\t\"./cy\": \"./node_modules/moment/locale/cy.js\",\n\t\"./cy.js\": \"./node_modules/moment/locale/cy.js\",\n\t\"./da\": \"./node_modules/moment/locale/da.js\",\n\t\"./da.js\": \"./node_modules/moment/locale/da.js\",\n\t\"./de\": \"./node_modules/moment/locale/de.js\",\n\t\"./de-at\": \"./node_modules/moment/locale/de-at.js\",\n\t\"./de-at.js\": \"./node_modules/moment/locale/de-at.js\",\n\t\"./de-ch\": \"./node_modules/moment/locale/de-ch.js\",\n\t\"./de-ch.js\": \"./node_modules/moment/locale/de-ch.js\",\n\t\"./de.js\": \"./node_modules/moment/locale/de.js\",\n\t\"./dv\": \"./node_modules/moment/locale/dv.js\",\n\t\"./dv.js\": \"./node_modules/moment/locale/dv.js\",\n\t\"./el\": \"./node_modules/moment/locale/el.js\",\n\t\"./el.js\": \"./node_modules/moment/locale/el.js\",\n\t\"./en-au\": \"./node_modules/moment/locale/en-au.js\",\n\t\"./en-au.js\": \"./node_modules/moment/locale/en-au.js\",\n\t\"./en-ca\": \"./node_modules/moment/locale/en-ca.js\",\n\t\"./en-ca.js\": \"./node_modules/moment/locale/en-ca.js\",\n\t\"./en-gb\": \"./node_modules/moment/locale/en-gb.js\",\n\t\"./en-gb.js\": \"./node_modules/moment/locale/en-gb.js\",\n\t\"./en-ie\": \"./node_modules/moment/locale/en-ie.js\",\n\t\"./en-ie.js\": \"./node_modules/moment/locale/en-ie.js\",\n\t\"./en-il\": \"./node_modules/moment/locale/en-il.js\",\n\t\"./en-il.js\": \"./node_modules/moment/locale/en-il.js\",\n\t\"./en-in\": \"./node_modules/moment/locale/en-in.js\",\n\t\"./en-in.js\": \"./node_modules/moment/locale/en-in.js\",\n\t\"./en-nz\": \"./node_modules/moment/locale/en-nz.js\",\n\t\"./en-nz.js\": \"./node_modules/moment/locale/en-nz.js\",\n\t\"./en-sg\": \"./node_modules/moment/locale/en-sg.js\",\n\t\"./en-sg.js\": \"./node_modules/moment/locale/en-sg.js\",\n\t\"./eo\": \"./node_modules/moment/locale/eo.js\",\n\t\"./eo.js\": \"./node_modules/moment/locale/eo.js\",\n\t\"./es\": \"./node_modules/moment/locale/es.js\",\n\t\"./es-do\": \"./node_modules/moment/locale/es-do.js\",\n\t\"./es-do.js\": \"./node_modules/moment/locale/es-do.js\",\n\t\"./es-mx\": \"./node_modules/moment/locale/es-mx.js\",\n\t\"./es-mx.js\": \"./node_modules/moment/locale/es-mx.js\",\n\t\"./es-us\": \"./node_modules/moment/locale/es-us.js\",\n\t\"./es-us.js\": \"./node_modules/moment/locale/es-us.js\",\n\t\"./es.js\": \"./node_modules/moment/locale/es.js\",\n\t\"./et\": \"./node_modules/moment/locale/et.js\",\n\t\"./et.js\": \"./node_modules/moment/locale/et.js\",\n\t\"./eu\": \"./node_modules/moment/locale/eu.js\",\n\t\"./eu.js\": \"./node_modules/moment/locale/eu.js\",\n\t\"./fa\": \"./node_modules/moment/locale/fa.js\",\n\t\"./fa.js\": \"./node_modules/moment/locale/fa.js\",\n\t\"./fi\": \"./node_modules/moment/locale/fi.js\",\n\t\"./fi.js\": \"./node_modules/moment/locale/fi.js\",\n\t\"./fil\": \"./node_modules/moment/locale/fil.js\",\n\t\"./fil.js\": \"./node_modules/moment/locale/fil.js\",\n\t\"./fo\": \"./node_modules/moment/locale/fo.js\",\n\t\"./fo.js\": \"./node_modules/moment/locale/fo.js\",\n\t\"./fr\": \"./node_modules/moment/locale/fr.js\",\n\t\"./fr-ca\": \"./node_modules/moment/locale/fr-ca.js\",\n\t\"./fr-ca.js\": \"./node_modules/moment/locale/fr-ca.js\",\n\t\"./fr-ch\": \"./node_modules/moment/locale/fr-ch.js\",\n\t\"./fr-ch.js\": \"./node_modules/moment/locale/fr-ch.js\",\n\t\"./fr.js\": \"./node_modules/moment/locale/fr.js\",\n\t\"./fy\": \"./node_modules/moment/locale/fy.js\",\n\t\"./fy.js\": \"./node_modules/moment/locale/fy.js\",\n\t\"./ga\": \"./node_modules/moment/locale/ga.js\",\n\t\"./ga.js\": \"./node_modules/moment/locale/ga.js\",\n\t\"./gd\": \"./node_modules/moment/locale/gd.js\",\n\t\"./gd.js\": \"./node_modules/moment/locale/gd.js\",\n\t\"./gl\": \"./node_modules/moment/locale/gl.js\",\n\t\"./gl.js\": \"./node_modules/moment/locale/gl.js\",\n\t\"./gom-deva\": \"./node_modules/moment/locale/gom-deva.js\",\n\t\"./gom-deva.js\": \"./node_modules/moment/locale/gom-deva.js\",\n\t\"./gom-latn\": \"./node_modules/moment/locale/gom-latn.js\",\n\t\"./gom-latn.js\": \"./node_modules/moment/locale/gom-latn.js\",\n\t\"./gu\": \"./node_modules/moment/locale/gu.js\",\n\t\"./gu.js\": \"./node_modules/moment/locale/gu.js\",\n\t\"./he\": \"./node_modules/moment/locale/he.js\",\n\t\"./he.js\": \"./node_modules/moment/locale/he.js\",\n\t\"./hi\": \"./node_modules/moment/locale/hi.js\",\n\t\"./hi.js\": \"./node_modules/moment/locale/hi.js\",\n\t\"./hr\": \"./node_modules/moment/locale/hr.js\",\n\t\"./hr.js\": \"./node_modules/moment/locale/hr.js\",\n\t\"./hu\": \"./node_modules/moment/locale/hu.js\",\n\t\"./hu.js\": \"./node_modules/moment/locale/hu.js\",\n\t\"./hy-am\": \"./node_modules/moment/locale/hy-am.js\",\n\t\"./hy-am.js\": \"./node_modules/moment/locale/hy-am.js\",\n\t\"./id\": \"./node_modules/moment/locale/id.js\",\n\t\"./id.js\": \"./node_modules/moment/locale/id.js\",\n\t\"./is\": \"./node_modules/moment/locale/is.js\",\n\t\"./is.js\": \"./node_modules/moment/locale/is.js\",\n\t\"./it\": \"./node_modules/moment/locale/it.js\",\n\t\"./it-ch\": \"./node_modules/moment/locale/it-ch.js\",\n\t\"./it-ch.js\": \"./node_modules/moment/locale/it-ch.js\",\n\t\"./it.js\": \"./node_modules/moment/locale/it.js\",\n\t\"./ja\": \"./node_modules/moment/locale/ja.js\",\n\t\"./ja.js\": \"./node_modules/moment/locale/ja.js\",\n\t\"./jv\": \"./node_modules/moment/locale/jv.js\",\n\t\"./jv.js\": \"./node_modules/moment/locale/jv.js\",\n\t\"./ka\": \"./node_modules/moment/locale/ka.js\",\n\t\"./ka.js\": \"./node_modules/moment/locale/ka.js\",\n\t\"./kk\": \"./node_modules/moment/locale/kk.js\",\n\t\"./kk.js\": \"./node_modules/moment/locale/kk.js\",\n\t\"./km\": \"./node_modules/moment/locale/km.js\",\n\t\"./km.js\": \"./node_modules/moment/locale/km.js\",\n\t\"./kn\": \"./node_modules/moment/locale/kn.js\",\n\t\"./kn.js\": \"./node_modules/moment/locale/kn.js\",\n\t\"./ko\": \"./node_modules/moment/locale/ko.js\",\n\t\"./ko.js\": \"./node_modules/moment/locale/ko.js\",\n\t\"./ku\": \"./node_modules/moment/locale/ku.js\",\n\t\"./ku-kmr\": \"./node_modules/moment/locale/ku-kmr.js\",\n\t\"./ku-kmr.js\": \"./node_modules/moment/locale/ku-kmr.js\",\n\t\"./ku.js\": \"./node_modules/moment/locale/ku.js\",\n\t\"./ky\": \"./node_modules/moment/locale/ky.js\",\n\t\"./ky.js\": \"./node_modules/moment/locale/ky.js\",\n\t\"./lb\": \"./node_modules/moment/locale/lb.js\",\n\t\"./lb.js\": \"./node_modules/moment/locale/lb.js\",\n\t\"./lo\": \"./node_modules/moment/locale/lo.js\",\n\t\"./lo.js\": \"./node_modules/moment/locale/lo.js\",\n\t\"./lt\": \"./node_modules/moment/locale/lt.js\",\n\t\"./lt.js\": \"./node_modules/moment/locale/lt.js\",\n\t\"./lv\": \"./node_modules/moment/locale/lv.js\",\n\t\"./lv.js\": \"./node_modules/moment/locale/lv.js\",\n\t\"./me\": \"./node_modules/moment/locale/me.js\",\n\t\"./me.js\": \"./node_modules/moment/locale/me.js\",\n\t\"./mi\": \"./node_modules/moment/locale/mi.js\",\n\t\"./mi.js\": \"./node_modules/moment/locale/mi.js\",\n\t\"./mk\": \"./node_modules/moment/locale/mk.js\",\n\t\"./mk.js\": \"./node_modules/moment/locale/mk.js\",\n\t\"./ml\": \"./node_modules/moment/locale/ml.js\",\n\t\"./ml.js\": \"./node_modules/moment/locale/ml.js\",\n\t\"./mn\": \"./node_modules/moment/locale/mn.js\",\n\t\"./mn.js\": \"./node_modules/moment/locale/mn.js\",\n\t\"./mr\": \"./node_modules/moment/locale/mr.js\",\n\t\"./mr.js\": \"./node_modules/moment/locale/mr.js\",\n\t\"./ms\": \"./node_modules/moment/locale/ms.js\",\n\t\"./ms-my\": \"./node_modules/moment/locale/ms-my.js\",\n\t\"./ms-my.js\": \"./node_modules/moment/locale/ms-my.js\",\n\t\"./ms.js\": \"./node_modules/moment/locale/ms.js\",\n\t\"./mt\": \"./node_modules/moment/locale/mt.js\",\n\t\"./mt.js\": \"./node_modules/moment/locale/mt.js\",\n\t\"./my\": \"./node_modules/moment/locale/my.js\",\n\t\"./my.js\": \"./node_modules/moment/locale/my.js\",\n\t\"./nb\": \"./node_modules/moment/locale/nb.js\",\n\t\"./nb.js\": \"./node_modules/moment/locale/nb.js\",\n\t\"./ne\": \"./node_modules/moment/locale/ne.js\",\n\t\"./ne.js\": \"./node_modules/moment/locale/ne.js\",\n\t\"./nl\": \"./node_modules/moment/locale/nl.js\",\n\t\"./nl-be\": \"./node_modules/moment/locale/nl-be.js\",\n\t\"./nl-be.js\": \"./node_modules/moment/locale/nl-be.js\",\n\t\"./nl.js\": \"./node_modules/moment/locale/nl.js\",\n\t\"./nn\": \"./node_modules/moment/locale/nn.js\",\n\t\"./nn.js\": \"./node_modules/moment/locale/nn.js\",\n\t\"./oc-lnc\": \"./node_modules/moment/locale/oc-lnc.js\",\n\t\"./oc-lnc.js\": \"./node_modules/moment/locale/oc-lnc.js\",\n\t\"./pa-in\": \"./node_modules/moment/locale/pa-in.js\",\n\t\"./pa-in.js\": \"./node_modules/moment/locale/pa-in.js\",\n\t\"./pl\": \"./node_modules/moment/locale/pl.js\",\n\t\"./pl.js\": \"./node_modules/moment/locale/pl.js\",\n\t\"./pt\": \"./node_modules/moment/locale/pt.js\",\n\t\"./pt-br\": \"./node_modules/moment/locale/pt-br.js\",\n\t\"./pt-br.js\": \"./node_modules/moment/locale/pt-br.js\",\n\t\"./pt.js\": \"./node_modules/moment/locale/pt.js\",\n\t\"./ro\": \"./node_modules/moment/locale/ro.js\",\n\t\"./ro.js\": \"./node_modules/moment/locale/ro.js\",\n\t\"./ru\": \"./node_modules/moment/locale/ru.js\",\n\t\"./ru.js\": \"./node_modules/moment/locale/ru.js\",\n\t\"./sd\": \"./node_modules/moment/locale/sd.js\",\n\t\"./sd.js\": \"./node_modules/moment/locale/sd.js\",\n\t\"./se\": \"./node_modules/moment/locale/se.js\",\n\t\"./se.js\": \"./node_modules/moment/locale/se.js\",\n\t\"./si\": \"./node_modules/moment/locale/si.js\",\n\t\"./si.js\": \"./node_modules/moment/locale/si.js\",\n\t\"./sk\": \"./node_modules/moment/locale/sk.js\",\n\t\"./sk.js\": \"./node_modules/moment/locale/sk.js\",\n\t\"./sl\": \"./node_modules/moment/locale/sl.js\",\n\t\"./sl.js\": \"./node_modules/moment/locale/sl.js\",\n\t\"./sq\": \"./node_modules/moment/locale/sq.js\",\n\t\"./sq.js\": \"./node_modules/moment/locale/sq.js\",\n\t\"./sr\": \"./node_modules/moment/locale/sr.js\",\n\t\"./sr-cyrl\": \"./node_modules/moment/locale/sr-cyrl.js\",\n\t\"./sr-cyrl.js\": \"./node_modules/moment/locale/sr-cyrl.js\",\n\t\"./sr.js\": \"./node_modules/moment/locale/sr.js\",\n\t\"./ss\": \"./node_modules/moment/locale/ss.js\",\n\t\"./ss.js\": \"./node_modules/moment/locale/ss.js\",\n\t\"./sv\": \"./node_modules/moment/locale/sv.js\",\n\t\"./sv.js\": \"./node_modules/moment/locale/sv.js\",\n\t\"./sw\": \"./node_modules/moment/locale/sw.js\",\n\t\"./sw.js\": \"./node_modules/moment/locale/sw.js\",\n\t\"./ta\": \"./node_modules/moment/locale/ta.js\",\n\t\"./ta.js\": \"./node_modules/moment/locale/ta.js\",\n\t\"./te\": \"./node_modules/moment/locale/te.js\",\n\t\"./te.js\": \"./node_modules/moment/locale/te.js\",\n\t\"./tet\": \"./node_modules/moment/locale/tet.js\",\n\t\"./tet.js\": \"./node_modules/moment/locale/tet.js\",\n\t\"./tg\": \"./node_modules/moment/locale/tg.js\",\n\t\"./tg.js\": \"./node_modules/moment/locale/tg.js\",\n\t\"./th\": \"./node_modules/moment/locale/th.js\",\n\t\"./th.js\": \"./node_modules/moment/locale/th.js\",\n\t\"./tk\": \"./node_modules/moment/locale/tk.js\",\n\t\"./tk.js\": \"./node_modules/moment/locale/tk.js\",\n\t\"./tl-ph\": \"./node_modules/moment/locale/tl-ph.js\",\n\t\"./tl-ph.js\": \"./node_modules/moment/locale/tl-ph.js\",\n\t\"./tlh\": \"./node_modules/moment/locale/tlh.js\",\n\t\"./tlh.js\": \"./node_modules/moment/locale/tlh.js\",\n\t\"./tr\": \"./node_modules/moment/locale/tr.js\",\n\t\"./tr.js\": \"./node_modules/moment/locale/tr.js\",\n\t\"./tzl\": \"./node_modules/moment/locale/tzl.js\",\n\t\"./tzl.js\": \"./node_modules/moment/locale/tzl.js\",\n\t\"./tzm\": \"./node_modules/moment/locale/tzm.js\",\n\t\"./tzm-latn\": \"./node_modules/moment/locale/tzm-latn.js\",\n\t\"./tzm-latn.js\": \"./node_modules/moment/locale/tzm-latn.js\",\n\t\"./tzm.js\": \"./node_modules/moment/locale/tzm.js\",\n\t\"./ug-cn\": \"./node_modules/moment/locale/ug-cn.js\",\n\t\"./ug-cn.js\": \"./node_modules/moment/locale/ug-cn.js\",\n\t\"./uk\": \"./node_modules/moment/locale/uk.js\",\n\t\"./uk.js\": \"./node_modules/moment/locale/uk.js\",\n\t\"./ur\": \"./node_modules/moment/locale/ur.js\",\n\t\"./ur.js\": \"./node_modules/moment/locale/ur.js\",\n\t\"./uz\": \"./node_modules/moment/locale/uz.js\",\n\t\"./uz-latn\": \"./node_modules/moment/locale/uz-latn.js\",\n\t\"./uz-latn.js\": \"./node_modules/moment/locale/uz-latn.js\",\n\t\"./uz.js\": \"./node_modules/moment/locale/uz.js\",\n\t\"./vi\": \"./node_modules/moment/locale/vi.js\",\n\t\"./vi.js\": \"./node_modules/moment/locale/vi.js\",\n\t\"./x-pseudo\": \"./node_modules/moment/locale/x-pseudo.js\",\n\t\"./x-pseudo.js\": \"./node_modules/moment/locale/x-pseudo.js\",\n\t\"./yo\": \"./node_modules/moment/locale/yo.js\",\n\t\"./yo.js\": \"./node_modules/moment/locale/yo.js\",\n\t\"./zh-cn\": \"./node_modules/moment/locale/zh-cn.js\",\n\t\"./zh-cn.js\": \"./node_modules/moment/locale/zh-cn.js\",\n\t\"./zh-hk\": \"./node_modules/moment/locale/zh-hk.js\",\n\t\"./zh-hk.js\": \"./node_modules/moment/locale/zh-hk.js\",\n\t\"./zh-mo\": \"./node_modules/moment/locale/zh-mo.js\",\n\t\"./zh-mo.js\": \"./node_modules/moment/locale/zh-mo.js\",\n\t\"./zh-tw\": \"./node_modules/moment/locale/zh-tw.js\",\n\t\"./zh-tw.js\": \"./node_modules/moment/locale/zh-tw.js\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./node_modules/moment/locale sync recursive ^\\\\.\\\\/.*$\";","/* eslint react/forbid-prop-types: 0 */\nimport _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport FilterGroup from '@gen3/ui-component/dist/components/filters/FilterGroup';\nimport FilterList from '@gen3/ui-component/dist/components/filters/FilterList';\nimport {\n  getFilterSections,\n  excludeSelfFilterFromAggsData,\n} from './utils';\nimport { ENUM_ACCESSIBILITY } from '../Utils/const';\nimport {\n  askGuppyAboutArrayTypes,\n  askGuppyForAggregationData,\n  getAllFieldsFromFilterConfigs,\n} from '../Utils/queries';\nimport {\n  mergeFilters,\n  updateCountsInInitialTabsOptions,\n  sortTabsOptions,\n  mergeTabOptions,\n  buildFilterStatusForURLFilter,\n} from '../Utils/filters';\n\nclass ConnectedFilter extends React.Component {\n  constructor(props) {\n    super(props);\n\n    const filterConfigsFields = getAllFieldsFromFilterConfigs(props.filterConfig.tabs);\n    const filterConfigsRegularAggFields = filterConfigsFields.fields || [];\n    const filterConfigsAsTextAggFields = filterConfigsFields.asTextAggFields || [];\n    const allRegularAggFields = props.accessibleFieldCheckList\n      ? _.union(filterConfigsRegularAggFields, props.accessibleFieldCheckList)\n      : filterConfigsRegularAggFields;\n    // props.extraAggsFields are chart fields, use asTextAgg for all of them\n    const allAsTextAggFields = _.union(filterConfigsAsTextAggFields, this.props.extraAggsFields);\n\n    this.initialTabsOptions = {};\n    let initialFilter = this.props.adminAppliedPreFilters;\n    let filterStatusArray = [];\n    let filtersApplied = {};\n    if (this.props.userFilterFromURL && Object.keys(this.props.userFilterFromURL).length > 0) {\n      filterStatusArray = buildFilterStatusForURLFilter(\n        this.props.userFilterFromURL,\n        this.getTabsWithSearchFields(),\n      );\n      filtersApplied = this.props.userFilterFromURL;\n      initialFilter = mergeFilters(this.props.userFilterFromURL, this.props.adminAppliedPreFilters);\n    }\n\n    this.state = {\n      allRegularAggFields,\n      allAsTextAggFields,\n      initialAggsData: {},\n      receivedAggsData: {},\n      accessibility: ENUM_ACCESSIBILITY.ALL,\n      adminAppliedPreFilters: { ...this.props.adminAppliedPreFilters },\n      filter: { ...initialFilter },\n      filtersApplied,\n      filterStatusArray,\n    };\n    this.filterGroupRef = React.createRef();\n    this.adminPreFiltersFrozen = JSON.stringify(this.props.adminAppliedPreFilters).slice();\n    this.arrayFields = [];\n  }\n\n  componentDidMount() {\n    if (this.props.onUpdateAccessLevel) {\n      this.props.onUpdateAccessLevel(this.state.accessibility);\n    }\n    if (this.props.onFilterChange) {\n      this.props.onFilterChange(this.state.adminAppliedPreFilters, this.state.accessibility);\n    }\n    askGuppyForAggregationData(\n      this.props.guppyConfig.path,\n      this.props.guppyConfig.type,\n      this.state.allRegularAggFields,\n      this.state.allAsTextAggFields,\n      this.state.filter,\n      this.state.accessibility,\n      this.props.csrfToken,\n    )\n      .then((res) => {\n        if (!res.data) {\n          const msg = `error querying guppy${res.errors && res.errors.length > 0 ? `: ${res.errors[0].message}` : ''}`;\n          console.error(msg); // eslint-disable-line no-console\n        }\n        this.handleReceiveNewAggsData(\n          res.data._aggregation[this.props.guppyConfig.type],\n          this.state.adminAppliedPreFilters,\n        );\n        this.saveInitialAggsData(res.data._aggregation[this.props.guppyConfig.type]);\n      });\n\n    askGuppyAboutArrayTypes(this.props.guppyConfig.path).then((res) => {\n      this.arrayFields = [];\n      const keys = Object.keys(res);\n\n      for (let i = 0; i < keys.length; i += 1) {\n        if (res[keys[i]].arrayFields && res[keys[i]].arrayFields.length > 0) {\n          this.arrayFields = this.arrayFields.concat(res[keys[i]].arrayFields);\n        }\n      }\n    });\n  }\n\n  handleReceiveNewAggsData(receivedAggsData, filterResults) {\n    this.setState({ receivedAggsData });\n    if (this.props.onReceiveNewAggsData) {\n      const resultAggsData = excludeSelfFilterFromAggsData(receivedAggsData, filterResults);\n      this.props.onReceiveNewAggsData(resultAggsData);\n    }\n  }\n\n  /**\n   * Handler function that is called every time filter changes\n   * What this function does:\n   * 1. Ask guppy for aggregation data using (processed) filter\n   * 2. After get aggregation response, call `handleReceiveNewAggsData` handler\n   *    to process new received agg data\n   * 3. If there's `onFilterChange` callback function from parent, call it\n   * @param {object} filterResults\n   */\n  handleFilterChange(filterResults) {\n    this.setState({ adminAppliedPreFilters: JSON.parse(this.adminPreFiltersFrozen) });\n    const mergedFilterResults = mergeFilters(filterResults, JSON.parse(this.adminPreFiltersFrozen));\n\n    const newFilterStatusArray = buildFilterStatusForURLFilter(\n      mergedFilterResults,\n      this.getTabsWithSearchFields(),\n    );\n\n    this.setState({ filtersApplied: mergedFilterResults, filterStatusArray: newFilterStatusArray });\n    askGuppyForAggregationData(\n      this.props.guppyConfig.path,\n      this.props.guppyConfig.type,\n      this.state.allRegularAggFields,\n      this.state.allAsTextAggFields,\n      mergedFilterResults,\n      this.state.accessibility,\n      this.props.csrfToken,\n    )\n      .then((res) => {\n        this.handleReceiveNewAggsData(\n          res.data._aggregation[this.props.guppyConfig.type],\n          mergedFilterResults,\n        );\n      });\n\n    if (this.props.onFilterChange) {\n      this.props.onFilterChange(mergedFilterResults, this.state.accessibility);\n    }\n  }\n\n  getTabsWithSearchFields() {\n    const newTabs = this.props.filterConfig.tabs.map(({\n      title, fields, searchFields, asTextAggFields = [],\n    }) => {\n      if (searchFields) {\n        return { title, fields: searchFields.concat(fields).concat(asTextAggFields) };\n      }\n      return { title, fields: fields.concat(asTextAggFields) };\n    });\n    return newTabs;\n  }\n\n  // eslint-disable-next-line react/no-unused-class-component-methods\n  setFilter(filter) {\n    if (this.filterGroupRef.current) {\n      this.filterGroupRef.current.resetFilter();\n    }\n    this.handleFilterChange(filter);\n  }\n\n  /**\n   * This function contains partial rendering logic for filter components.\n   * It transfers aggregation data (`this.state.receivedAggsData`) to items inside filters.\n   * But before that, the function first calls `this.props.onProcessFilterAggsData`, which is\n   * a callback function passed by `ConnectedFilter`'s parent component, so that the parent\n   * component could do some pre-processing modification about filter.\n   */\n  getFilterTabs() {\n    const filtersToDisplay = this.state.filtersApplied;\n    if (this.props.hidden) return null;\n    let processedTabsOptions = this.props.onProcessFilterAggsData(this.state.receivedAggsData);\n\n    // Get filter values\n    const allFilterValues = this.props.filterConfig.tabs.reduce(\n      (accumulator, tab) => ([...accumulator, ...tab.fields, ...tab.asTextAggFields || []]),\n      [],\n    );\n\n    if (Object.keys(this.initialTabsOptions).length === 0) {\n      this.initialTabsOptions = processedTabsOptions;\n    }\n\n    processedTabsOptions = updateCountsInInitialTabsOptions(\n      this.initialTabsOptions,\n      processedTabsOptions,\n      filtersToDisplay,\n      // for tiered access filters\n      this.props.tierAccessLimit ? this.props.accessibleFieldCheckList : [],\n      allFilterValues,\n    );\n\n    if (Object.keys(filtersToDisplay).length) {\n      // if has applied filters, sort tab options as selected/unselected separately\n      const selectedTabsOptions = {};\n      const unselectedTabsOptions = {};\n      Object.keys(processedTabsOptions).forEach((opt) => {\n        if (!processedTabsOptions[`${opt}`].histogram.length) {\n          if (!unselectedTabsOptions[`${opt}`]) {\n            unselectedTabsOptions[`${opt}`] = {};\n          }\n          unselectedTabsOptions[`${opt}`].histogram = [];\n          return;\n        }\n        processedTabsOptions[`${opt}`].histogram.forEach((entry) => {\n          if (filtersToDisplay[`${opt}`]\n          && filtersToDisplay[`${opt}`].selectedValues\n          && filtersToDisplay[`${opt}`].selectedValues.includes(entry.key)) {\n            if (!selectedTabsOptions[`${opt}`]) {\n              selectedTabsOptions[`${opt}`] = {};\n            }\n            if (!selectedTabsOptions[`${opt}`].histogram) {\n              selectedTabsOptions[`${opt}`].histogram = [];\n            }\n            selectedTabsOptions[`${opt}`].histogram.push({ key: entry.key, count: entry.count });\n          } else {\n            if (!unselectedTabsOptions[`${opt}`]) {\n              unselectedTabsOptions[`${opt}`] = {};\n            }\n            if (typeof (entry.key) !== 'string') { // if it is a range filter, just copy and return\n              unselectedTabsOptions[`${opt}`].histogram = processedTabsOptions[`${opt}`].histogram;\n              return;\n            }\n            if (!unselectedTabsOptions[`${opt}`].histogram) {\n              unselectedTabsOptions[`${opt}`].histogram = [];\n            }\n            unselectedTabsOptions[`${opt}`].histogram.push({ key: entry.key, count: entry.count });\n          }\n        });\n      });\n\n      // For search filters: If there are any search filters present, include\n      // the selected options in the `selectedTabsOptions` array.\n      // ------\n      let allSearchFields = [];\n      this.props.filterConfig.tabs.forEach((tab) => {\n        allSearchFields = allSearchFields.concat(tab.searchFields);\n      });\n      allSearchFields.forEach((field) => {\n        if (filtersToDisplay[`${field}`]) {\n          const { selectedValues } = filtersToDisplay[`${field}`];\n          if (selectedValues) {\n            filtersToDisplay[`${field}`].selectedValues.forEach((val) => {\n              if (!selectedTabsOptions[`${field}`]) {\n                selectedTabsOptions[`${field}`] = {};\n              }\n              if (!selectedTabsOptions[`${field}`].histogram) {\n                selectedTabsOptions[`${field}`].histogram = [];\n              }\n              selectedTabsOptions[`${field}`].histogram.push({ key: val });\n            });\n          }\n        }\n      });\n      // -------\n      processedTabsOptions = mergeTabOptions(\n        sortTabsOptions(selectedTabsOptions),\n        sortTabsOptions(unselectedTabsOptions),\n      );\n    } else {\n      processedTabsOptions = sortTabsOptions(processedTabsOptions);\n    }\n    if (!processedTabsOptions || Object.keys(processedTabsOptions).length === 0) return null;\n    const { fieldMapping } = this.props;\n    const tabs = this.props.filterConfig.tabs.map(({ fields, searchFields, asTextAggFields = [] }, index) => {\n      const aggFields = _.union(fields, asTextAggFields);\n      const sections = getFilterSections(\n        aggFields,\n        searchFields,\n        fieldMapping,\n        processedTabsOptions,\n        this.state.initialAggsData,\n        this.state.adminAppliedPreFilters,\n        this.props.guppyConfig,\n        this.arrayFields,\n        this.props.filterValuesToHide,\n        this.props.csrfToken,\n      );\n      const filterStatus = this.state.filterStatusArray\n        ? this.state.filterStatusArray[index] : null;\n      return (\n        <FilterList\n          key={index}\n          sections={sections}\n          hideEmptyFilterSection={this.props.hideEmptyFilterSection}\n          tierAccessLimit={this.props.tierAccessLimit}\n          lockedTooltipMessage={this.props.lockedTooltipMessage}\n          disabledTooltipMessage={this.props.disabledTooltipMessage}\n          arrayFields={this.arrayFields}\n          filterStatusFromParent={filterStatus}\n        />\n      );\n    });\n    return tabs;\n  }\n\n  /**\n   * Save initial aggregation data, especially for range slider\n   * so that we still have min/max values for range slider\n   * @param {object} aggsData\n   */\n  saveInitialAggsData(aggsData) {\n    this.setState({ initialAggsData: aggsData });\n  }\n\n  render() {\n    if (this.props.hidden) return null;\n    const filterTabs = this.getFilterTabs();\n    if (!filterTabs || filterTabs.length === 0) {\n      return null;\n    }\n    // If there are any search fields, insert them at the top of each tab's fields.\n    const filterConfig = {\n      tabs: this.getTabsWithSearchFields(),\n    };\n    return (\n      <FilterGroup\n        ref={this.filterGroupRef}\n        className={this.props.className}\n        tabs={filterTabs}\n        filterConfig={filterConfig}\n        onFilterChange={(e) => this.handleFilterChange(e)}\n        hideZero={this.props.hideZero}\n        filterStatusFromParent={this.state.filterStatusArray}\n        filterResultsFromParent={this.state.filtersApplied}\n      />\n    );\n  }\n}\n\nConnectedFilter.propTypes = {\n  filterConfig: PropTypes.shape({\n    tabs: PropTypes.arrayOf(PropTypes.shape({\n      title: PropTypes.string,\n      fields: PropTypes.arrayOf(PropTypes.string),\n      asTextAggFields: PropTypes.arrayOf(PropTypes.string),\n      searchFields: PropTypes.arrayOf(PropTypes.string),\n    })),\n  }).isRequired,\n  extraAggsFields: PropTypes.arrayOf(PropTypes.string),\n  guppyConfig: PropTypes.shape({\n    path: PropTypes.string.isRequired,\n    type: PropTypes.string.isRequired,\n  }).isRequired,\n  onFilterChange: PropTypes.func,\n  onReceiveNewAggsData: PropTypes.func,\n  className: PropTypes.string,\n  fieldMapping: PropTypes.arrayOf(PropTypes.shape({\n    field: PropTypes.string,\n    name: PropTypes.string,\n  })),\n  tierAccessLimit: PropTypes.number,\n  onProcessFilterAggsData: PropTypes.func,\n  onUpdateAccessLevel: PropTypes.func,\n  adminAppliedPreFilters: PropTypes.object,\n  lockedTooltipMessage: PropTypes.string,\n  disabledTooltipMessage: PropTypes.string,\n  accessibleFieldCheckList: PropTypes.arrayOf(PropTypes.string),\n  hideZero: PropTypes.bool,\n  hidden: PropTypes.bool,\n  userFilterFromURL: PropTypes.object,\n  hideEmptyFilterSection: PropTypes.bool,\n  filterValuesToHide: PropTypes.arrayOf(PropTypes.string),\n  csrfToken: PropTypes.string,\n};\n\nConnectedFilter.defaultProps = {\n  extraAggsFields: [],\n  onFilterChange: () => {},\n  onReceiveNewAggsData: () => {},\n  className: '',\n  fieldMapping: [],\n  tierAccessLimit: undefined,\n  onProcessFilterAggsData: (data) => (data),\n  onUpdateAccessLevel: () => {},\n  adminAppliedPreFilters: {},\n  lockedTooltipMessage: '',\n  disabledTooltipMessage: '',\n  accessibleFieldCheckList: undefined,\n  hideZero: false,\n  hidden: false,\n  userFilterFromURL: {},\n  hideEmptyFilterSection: false,\n  filterValuesToHide: [],\n  csrfToken: '',\n};\n\nexport default ConnectedFilter;\n","import flat from 'flat';\nimport { queryGuppyForRawDataAndTotalCounts } from '../Utils/queries';\n\nconst getSingleFilterOption = (histogramResult, initHistogramRes, filterValuesToHide) => {\n  if (!histogramResult || !histogramResult.histogram) {\n    throw new Error(`Error parsing field options ${JSON.stringify(histogramResult)}`);\n  }\n  // if this is for range slider\n  if (histogramResult.histogram.length === 1 && (typeof histogramResult.histogram[0].key) !== 'string') {\n    const rangeOptions = histogramResult.histogram.map((item) => {\n      const minValue = initHistogramRes ? initHistogramRes.histogram[0].key[0] : item.key[0];\n      const maxValue = initHistogramRes ? initHistogramRes.histogram[0].key[1] : item.key[1];\n      return {\n        filterType: 'range',\n        min: Math.floor(minValue),\n        max: Math.ceil(maxValue),\n        lowerBound: item.key[0],\n        upperBound: item.key[1],\n        count: item.count,\n      };\n    });\n    return rangeOptions;\n  }\n  let rawTextOptions = histogramResult.histogram;\n  // hide filterValuesToHide from filters\n  // filterValuesToHide added to guppyConfig in data-portal\n  if (filterValuesToHide.length > 0) {\n    rawTextOptions = histogramResult.histogram\n      .filter((item) => filterValuesToHide.indexOf(item.key) < 0);\n  }\n  const textOptions = rawTextOptions.map((item) => ({\n    text: item.key,\n    filterType: 'singleSelect',\n    count: item.count,\n    accessible: item.accessible,\n  }));\n  return textOptions;\n};\n\nconst capitalizeFirstLetter = (str) => {\n  const res = str.replace(/_|\\./gi, ' ');\n  return res.replace(/\\w\\S*/g, (txt) => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase());\n};\n\n// createSearchFilterLoadOptionsFn creates a handler function that loads the search filter's\n// autosuggest options as the user types in the search filter.\nconst createSearchFilterLoadOptionsFn = (field, guppyConfig) => (searchString, offset) => {\n  const NUM_SEARCH_OPTIONS = 20;\n  return new Promise((resolve, reject) => {\n    // If searchString is empty return just the first NUM_SEARCH_OPTIONS options.\n    // This allows the client to show default options in the search filter before\n    // the user has started searching.\n    let filter = {};\n    if (searchString) {\n      filter = {\n        search: {\n          keyword: searchString,\n          fields: [field],\n        },\n      };\n    }\n    queryGuppyForRawDataAndTotalCounts(\n      guppyConfig.path,\n      guppyConfig.type,\n      [field],\n      filter,\n      undefined,\n      undefined,\n      offset,\n      NUM_SEARCH_OPTIONS,\n      'accessible',\n    )\n      .then((res) => {\n        if (!res.data || !res.data[guppyConfig.type]) {\n          resolve({\n            options: [],\n            hasMore: false,\n          });\n        } else {\n          const results = res.data[guppyConfig.type];\n          const totalCount = res.data._aggregation[guppyConfig.type]._totalCount;\n          resolve({\n            options: results.map((result) => ({ value: result[field], label: result[field] })),\n            hasMore: totalCount > offset + results.length,\n          });\n        }\n      }).catch((err) => {\n        reject(err);\n      });\n  });\n};\n\nexport const checkIsArrayField = (field, arrayFields) => {\n  let isArrayField = false;\n  const keys = Object.keys(arrayFields);\n  for (let i = 0; i < keys.length; i += 1) {\n    if (arrayFields[keys[i]].includes(field)) {\n      isArrayField = true;\n    }\n  }\n  return isArrayField;\n};\n\nexport const getFilterSections = (\n  aggFields,\n  searchFields,\n  fieldMapping,\n  tabsOptions,\n  initialTabsOptions,\n  adminAppliedPreFilters,\n  guppyConfig,\n  arrayFields,\n  filterValuesToHide,\n  csrfToken,\n) => {\n  let searchFieldSections = [];\n\n  if (searchFields) {\n    // Process searchFields first -- searchFields are special filters that allow the user\n    // to search over all options, instead of displaying all options in a list. This allows\n    // guppy/portal to support filters that have too many options to be displayed in a list.\n    searchFieldSections = searchFields.map((field) => {\n      const overrideName = fieldMapping.find((entry) => (entry.field === field));\n      const label = overrideName ? overrideName.name : capitalizeFirstLetter(field);\n\n      const tabsOptionsFiltered = { ...tabsOptions[field] };\n      if (Object.keys(adminAppliedPreFilters).includes(field)) {\n        tabsOptionsFiltered.histogram = tabsOptionsFiltered.histogram.filter(\n          (x) => adminAppliedPreFilters[field].selectedValues.includes(x.key),\n        );\n      }\n\n      // For searchFields, don't pass all options to the component, only the selected ones.\n      // This allows selected options to appear below the search box once they are selected.\n      let selectedOptions = [];\n      if (tabsOptionsFiltered && tabsOptionsFiltered.histogram) {\n        selectedOptions = getSingleFilterOption(\n          tabsOptionsFiltered,\n          initialTabsOptions ? initialTabsOptions[field] : undefined,\n          filterValuesToHide,\n        );\n      }\n\n      return {\n        title: label,\n        options: selectedOptions,\n        isSearchFilter: true,\n        onSearchFilterLoadOptions: createSearchFilterLoadOptionsFn(field, guppyConfig, csrfToken),\n      };\n    });\n  }\n\n  const sections = aggFields.map((field) => {\n    const overrideName = fieldMapping.find((entry) => (entry.field === field));\n    const label = overrideName ? overrideName.name : capitalizeFirstLetter(field);\n\n    const tabsOptionsFiltered = { ...tabsOptions[field] };\n    if (Object.keys(adminAppliedPreFilters).includes(field)) {\n      tabsOptionsFiltered.histogram = tabsOptionsFiltered.histogram.filter(\n        (x) => adminAppliedPreFilters[field].selectedValues.includes(x.key),\n      );\n    }\n\n    const defaultOptions = getSingleFilterOption(\n      tabsOptionsFiltered,\n      initialTabsOptions ? initialTabsOptions[field] : undefined,\n      filterValuesToHide,\n    );\n\n    const fieldIsArrayField = checkIsArrayField(field, arrayFields);\n\n    return {\n      title: label,\n      options: defaultOptions,\n      isArrayField: fieldIsArrayField,\n    };\n  });\n  return searchFieldSections.concat(sections);\n};\n\nexport const excludeSelfFilterFromAggsData = (receivedAggsData, filterResults) => {\n  if (!filterResults) return receivedAggsData;\n  const resultAggsData = {};\n  const flattenAggsData = flat(receivedAggsData, { safe: true });\n  Object.keys(flattenAggsData).forEach((field) => {\n    const actualFieldName = field.replace('.histogram', '').replace('.asTextHistogram', '');\n    const histogram = flattenAggsData[`${field}`];\n    if (!histogram) return;\n    if (actualFieldName in filterResults) {\n      let resultHistogram = [];\n      if (typeof filterResults[`${actualFieldName}`].selectedValues !== 'undefined') {\n        const { selectedValues } = filterResults[`${actualFieldName}`];\n        resultHistogram = histogram.filter((bucket) => selectedValues.includes(bucket.key));\n      }\n      resultAggsData[`${actualFieldName}`] = { histogram: resultHistogram };\n    } else {\n      resultAggsData[`${actualFieldName}`] = { histogram: flattenAggsData[`${field}`] };\n    }\n  });\n  return resultAggsData;\n};\n","export const ENUM_ACCESSIBILITY = {\n  ACCESSIBLE: 'accessible',\n  UNACCESSIBLE: 'unaccessible',\n  ALL: 'all',\n};\n\nexport const FILE_FORMATS = {\n  JSON: 'json',\n  TSV: 'tsv',\n  CSV: 'csv',\n};\n\nexport const FILE_DELIMITERS = {\n  tsv: '\\t',\n  csv: ',',\n};\n","import { FILE_DELIMITERS } from './const';\n\nconst papaparse = require('papaparse');\nconst flatten = require('flat');\n\n/**\n * Flattens a deep nested JSON object skipping\n * the first level to avoid potentially flattening\n * non-nested data.\n * @param {JSON} json\n */\nexport async function flattenJson(json) {\n  const flattenedJson = [];\n  Object.keys(json).forEach((key) => {\n    flattenedJson.push(flatten(json[key], { delimiter: '_' }));\n  });\n  return flattenedJson;\n}\n\n/**\n * Converts JSON based on a config.\n * @param {JSON} json\n * @param {Object} config\n */\nexport async function conversion(json, config) {\n  return papaparse.unparse(json, config);\n}\n\n/**\n * Converts JSON to a specified file format.\n * Defaultes to JSON if file format is not supported.\n * @param {JSON} json\n * @param {string} format\n */\nexport async function jsonToFormat(json, format) {\n  if (format in FILE_DELIMITERS) {\n    const flatJson = await flattenJson(json);\n    const data = await conversion(flatJson, { delimiter: FILE_DELIMITERS[format] });\n    return data;\n  }\n  return json;\n}\n","import flat from 'flat';\nimport _ from 'lodash';\n\n/**\n   * This function takes two objects containing filters to be applied\n   * and combines them into one filter object in the same format.\n   * Note: the admin filter takes precedence. Selected values in the user\n   * filter will be discarded if the key collides. This is to avoid\n   * the user undoing the admin filter. (Multiple user checkboxes increase the\n   * amount of data shown when combined, but an admin filter should always decrease\n   * or keep constant the amount of data shown when combined with a user filter).\n  * */\nexport const mergeFilters = (userFilter, adminAppliedPreFilter) => {\n  const filterAB = { ...userFilter };\n  Object.keys(adminAppliedPreFilter).forEach((key) => {\n    if (Object.prototype.hasOwnProperty.call(userFilter, key)\n          && Object.prototype.hasOwnProperty.call(adminAppliedPreFilter, key)) {\n      const userFilterSubset = userFilter[key].selectedValues.filter(\n        (x) => adminAppliedPreFilter[key].selectedValues.includes(x),\n      );\n      if (userFilterSubset.length > 0) {\n        // The user-applied filter is more exclusive than the admin-applied filter.\n        filterAB[key].selectedValues = userFilter[key].selectedValues;\n      } else {\n        // The admin-applied filter is more exclusive than the user-applied filter.\n        filterAB[key].selectedValues = adminAppliedPreFilter[key].selectedValues;\n      }\n    } else if (Object.prototype.hasOwnProperty.call(adminAppliedPreFilter, key)) {\n      filterAB[key] = { selectedValues: adminAppliedPreFilter[key].selectedValues };\n    }\n  });\n\n  return filterAB;\n};\n\n/**\n   * This function updates the counts in the initial set of tab options\n   * calculated from unfiltered data.\n   * It is used to retain field options in the rendering if\n   * they are still checked but their counts are zero.\n   */\nexport const updateCountsInInitialTabsOptions = (\n  initialTabsOptions,\n  processedTabsOptions,\n  filtersApplied,\n  accessibleFieldCheckList,\n  allFilterValues,\n) => {\n  const updatedTabsOptions = {};\n  try {\n    // flatten the tab options first\n    // {\n    //   project_id.histogram: ...\n    //   visit.visit_label.histogram: ...\n    // }\n    const flattenInitialTabsOptions = flat(initialTabsOptions, { safe: true });\n    const flattenProcessedTabsOptions = flat(processedTabsOptions, { safe: true });\n    Object.keys(flattenInitialTabsOptions).forEach((field) => {\n      // in flattened tab options, to get actual field name, strip off the last '.histogram' or '.asTextHistogram'\n      const actualFieldName = field.replace('.histogram', '').replace('.asTextHistogram', '');\n\n      // check if Filter Value if not skip\n      if (!allFilterValues.includes(actualFieldName)) {\n        return;\n      }\n\n      // possible to have '.' in actualFieldName, so use it as a string\n      updatedTabsOptions[`${actualFieldName}`] = { histogram: [] };\n      // if in tiered access mode\n      // we need not to process filters for field in accessibleFieldCheckList\n      if (accessibleFieldCheckList\n        && accessibleFieldCheckList.includes(actualFieldName)\n        && flattenProcessedTabsOptions[`${field}`]) {\n        updatedTabsOptions[`${actualFieldName}`].histogram = flattenProcessedTabsOptions[`${field}`];\n        return;\n      }\n      const histogram = flattenInitialTabsOptions[`${field}`];\n      if (!histogram || typeof histogram !== 'object') {\n        console.error(`Guppy did not return histogram data for filter field ${actualFieldName}`); // eslint-disable-line no-console\n        return;\n      }\n      histogram.forEach((opt) => {\n        const { key } = opt;\n        if (typeof (key) !== 'string') { // key is a range, just copy the histogram\n          updatedTabsOptions[`${actualFieldName}`].histogram = flattenInitialTabsOptions[`${field}`];\n          if (flattenProcessedTabsOptions[`${field}`]\n            && flattenProcessedTabsOptions[`${field}`].length > 0\n            && updatedTabsOptions[`${actualFieldName}`].histogram) {\n            const currentFlattenProcessedTabsOptions = flattenProcessedTabsOptions[`${field}`][0];\n\n            // if empty count histogram should be removed so filter is not shown\n            if (currentFlattenProcessedTabsOptions.count === 0) {\n              updatedTabsOptions[`${actualFieldName}`].histogram = [];\n              return;\n            }\n            updatedTabsOptions[`${actualFieldName}`].histogram[0].count = currentFlattenProcessedTabsOptions.count;\n            const newKey = [0, 0];\n            if (currentFlattenProcessedTabsOptions.key[0]) {\n              // because of the prefer-destructuring eslint rule\n              const newLowerBound = currentFlattenProcessedTabsOptions.key[0];\n              newKey[0] = newLowerBound;\n            }\n            if (currentFlattenProcessedTabsOptions.key[1]) {\n              const newHigherBound = currentFlattenProcessedTabsOptions.key[1];\n              newKey[1] = newHigherBound;\n            }\n            updatedTabsOptions[`${actualFieldName}`].histogram[0].key = newKey;\n          }\n          return;\n        }\n        if (flattenProcessedTabsOptions[`${field}`]) {\n          const findOpt = flattenProcessedTabsOptions[`${field}`].find((o) => o.key === key);\n          if (findOpt) {\n            const { count } = findOpt;\n            updatedTabsOptions[`${actualFieldName}`].histogram.push({ key, count });\n          }\n        }\n      });\n      if (filtersApplied[`${actualFieldName}`]) {\n        if (filtersApplied[`${actualFieldName}`].selectedValues) {\n          filtersApplied[`${actualFieldName}`].selectedValues.forEach((optKey) => {\n            if (!updatedTabsOptions[`${actualFieldName}`].histogram.find((o) => o.key === optKey)) {\n              updatedTabsOptions[`${actualFieldName}`].histogram.push({ key: optKey, count: 0 });\n            }\n          });\n        }\n      }\n    });\n  } catch (err) {\n    /* eslint-disable no-console */\n    // hopefully we won't get here but in case of\n    // out-of-index error or obj undefined error\n    console.error('error when processing filter data: ', err);\n    console.trace();\n    /* eslint-enable no-console */\n  }\n  return updatedTabsOptions;\n};\n\nfunction sortCountThenAlpha(a, b) {\n  if (a.count === b.count) {\n    return a.key < b.key ? -1 : 1;\n  }\n  return b.count - a.count;\n}\n\nexport const sortTabsOptions = (tabsOptions) => {\n  const fields = Object.keys(tabsOptions);\n  const sortedTabsOptions = { ...tabsOptions };\n  for (let x = 0; x < fields.length; x += 1) {\n    const field = fields[x];\n\n    const optionsForThisField = sortedTabsOptions[field].histogram;\n    optionsForThisField.sort(sortCountThenAlpha);\n    sortedTabsOptions[field].histogram = optionsForThisField;\n  }\n  return sortedTabsOptions;\n};\n\n/**\n   * This function takes two TabsOptions object and merge them together\n   * The order of merged histogram array is preserved by firstHistogram.concat(secondHistogram)\n   */\nexport const mergeTabOptions = (firstTabsOptions, secondTabsOptions) => {\n  if (!firstTabsOptions || !Object.keys(firstTabsOptions).length) {\n    return secondTabsOptions;\n  }\n  if (!secondTabsOptions || !Object.keys(secondTabsOptions).length) {\n    return firstTabsOptions;\n  }\n\n  const allOptionKeys = _.union(Object.keys(firstTabsOptions), Object.keys(secondTabsOptions));\n  const mergedTabOptions = {};\n  allOptionKeys.forEach((optKey) => {\n    if (!mergedTabOptions[`${optKey}`]) {\n      mergedTabOptions[`${optKey}`] = {};\n    }\n    if (!mergedTabOptions[`${optKey}`].histogram) {\n      mergedTabOptions[`${optKey}`].histogram = [];\n    }\n    const firstHistogram = (firstTabsOptions[`${optKey}`] && firstTabsOptions[`${optKey}`].histogram) ? firstTabsOptions[`${optKey}`].histogram : [];\n    const secondHistogram = (secondTabsOptions[`${optKey}`] && secondTabsOptions[`${optKey}`].histogram) ? secondTabsOptions[`${optKey}`].histogram : [];\n    mergedTabOptions[`${optKey}`].histogram = firstHistogram.concat(secondHistogram);\n  });\n  return mergedTabOptions;\n};\n\nexport const buildFilterStatusForURLFilter = (userFilter, tabs) => {\n  // Converts filter-applied form to filter-displayed form\n  // TODO: add support for search filters\n  const filteringFields = Object.keys(userFilter);\n  const filterStatusArray = tabs.map(() => ([]));\n\n  for (let tabIndex = 0; tabIndex < tabs.length; tabIndex += 1) {\n    const allFieldsForThisTab = _.union(tabs[tabIndex].fields, tabs[tabIndex].asTextAggFields || []);\n    filterStatusArray[tabIndex] = allFieldsForThisTab.map(() => ({}));\n    for (let i = 0; i < filteringFields.length; i += 1) {\n      const sectionIndex = allFieldsForThisTab.indexOf(filteringFields[i]);\n      if (sectionIndex !== -1) {\n        let userFilterSmallForm = {};\n        const filterVar = userFilter[filteringFields[i]];\n        if (typeof filterVar === 'object' && filterVar.selectedValues) {\n          // Single select values:\n          for (let j = 0; j < filterVar.selectedValues.length; j += 1) {\n            userFilterSmallForm[filterVar.selectedValues[j]] = true;\n          }\n        } else if (typeof filterVar === 'object'\n          && (filterVar.lowerBound || filterVar.upperBound)) {\n          // Range values:\n          userFilterSmallForm = [filterVar.lowerBound, filterVar.upperBound];\n        }\n        filterStatusArray[tabIndex][sectionIndex] = userFilterSmallForm;\n      }\n    }\n  }\n\n  return filterStatusArray;\n};\n","import fetch from 'isomorphic-fetch';\nimport { jsonToFormat } from './conversion';\n\nconst graphqlEndpoint = '/graphql';\nconst downloadEndpoint = '/download';\nconst statusEndpoint = '/_status';\nconst headers = {\n  'Content-Type': 'application/json',\n};\n\nconst histogramQueryStrForEachField = (field, isAsTextAgg = false) => {\n  const splittedFieldArray = field.split('.');\n  const splittedField = splittedFieldArray.shift();\n  if (splittedFieldArray.length === 0) {\n    return (`\n    ${splittedField} {\n      ${(isAsTextAgg) ? 'asTextHistogram' : 'histogram'} {\n        key\n        count\n      }\n    }`);\n  }\n  return (`\n  ${splittedField} {\n    ${histogramQueryStrForEachField(splittedFieldArray.join('.'))}\n  }`);\n};\n\nconst queryGuppyForAggs = (path, type, regularAggFields, asTextAggFields, gqlFilter, acc, csrfToken = '') => {\n  let accessibility = acc;\n  if (accessibility !== 'all' && accessibility !== 'accessible' && accessibility !== 'unaccessible') {\n    accessibility = 'all';\n  }\n\n  const queryBody = {};\n  if (gqlFilter) {\n    const queryWithFilter = `query ($filter: JSON) {\n      _aggregation {\n        ${type} (filter: $filter, filterSelf: false, accessibility: ${accessibility}) {\n          ${regularAggFields.map((field) => histogramQueryStrForEachField(field, false))}\n          ${asTextAggFields.map((field) => histogramQueryStrForEachField(field, true))}\n        }\n      }\n    }`;\n    queryBody.variables = { filter: gqlFilter };\n    queryBody.query = queryWithFilter;\n  } else {\n    queryBody.query = `query {\n      _aggregation {\n        ${type} (accessibility: ${accessibility}) {\n          ${regularAggFields.map((field) => histogramQueryStrForEachField(field, false))}\n          ${asTextAggFields.map((field) => histogramQueryStrForEachField(field, true))}\n        }\n      }\n    }`;\n  }\n\n  return fetch(`${path}${graphqlEndpoint}`, {\n    method: 'POST',\n    headers: csrfToken ? { ...headers, 'x-csrf-token': csrfToken } : headers,\n    body: JSON.stringify(queryBody),\n  }).then((response) => response.json());\n};\n\nconst queryGuppyForStatus = (path) => fetch(`${path}${statusEndpoint}`, {\n  method: 'GET',\n  headers,\n}).then((response) => response.json());\n\nconst nestedHistogramQueryStrForEachField = (mainField, numericAggAsText) => (`\n  ${mainField} {\n    ${numericAggAsText ? 'asTextHistogram' : 'histogram'} {\n      key\n      count\n      missingFields {\n        field\n        count\n      }\n      termsFields {\n        field\n        count\n        terms {\n          key\n          count\n        }\n      }\n    }\n  }`);\n\nconst queryGuppyForSubAgg = (\n  path,\n  type,\n  mainField,\n  termsFields,\n  missingFields,\n  gqlFilter,\n  acc,\n  numericAggAsText = false,\n  csrfToken = '',\n) => {\n  let accessibility = acc;\n  if (accessibility !== 'all' && accessibility !== 'accessible' && accessibility !== 'unaccessible') {\n    accessibility = 'all';\n  }\n\n  const nestedAggFields = {};\n  if (termsFields) {\n    nestedAggFields.termsFields = termsFields;\n  }\n  if (missingFields) {\n    nestedAggFields.missingFields = missingFields;\n  }\n\n  const query = `query ($nestedAggFields: JSON) {\n    _aggregation {\n      ${type} (nestedAggFields: $nestedAggFields, accessibility: ${accessibility}) {\n        ${nestedHistogramQueryStrForEachField(mainField, numericAggAsText)}\n      }\n    }\n  }`;\n  const queryBody = { query };\n  queryBody.variables = { nestedAggFields };\n  if (gqlFilter) {\n    const queryWithFilter = `query ($filter: JSON, $nestedAggFields: JSON) {\n      _aggregation {\n        ${type} (filter: $filter, filterSelf: false, nestedAggFields: $nestedAggFields, accessibility: ${accessibility}) {\n          ${nestedHistogramQueryStrForEachField(mainField, numericAggAsText)}\n        }\n      }\n    }`;\n    queryBody.variables = { filter: gqlFilter, nestedAggFields };\n    queryBody.query = queryWithFilter;\n  }\n  return fetch(`${path}${graphqlEndpoint}`, {\n    method: 'POST',\n    headers: csrfToken ? { ...headers, 'x-csrf-token': csrfToken } : headers,\n    body: JSON.stringify(queryBody),\n  }).then((response) => response.json())\n    .catch((err) => {\n      throw new Error(`Error during queryGuppyForSubAgg ${err}`);\n    });\n};\n\nconst rawDataQueryStrForEachField = (field) => {\n  const splittedFieldArray = field.split('.');\n  const splittedField = splittedFieldArray.shift();\n  if (splittedFieldArray.length === 0) {\n    return (`\n    ${splittedField}\n    `);\n  }\n  return (`\n  ${splittedField} {\n    ${rawDataQueryStrForEachField(splittedFieldArray.join('.'))}\n  }`);\n};\n\nexport const queryGuppyForRawDataAndTotalCounts = (\n  path,\n  type,\n  fields,\n  gqlFilter,\n  sort,\n  format,\n  offset = 0,\n  size = 20,\n  accessibility = 'all',\n  csrfToken = '',\n) => {\n  let queryLine = 'query {';\n  if (gqlFilter || sort || format) {\n    queryLine = `query (${sort ? '$sort: JSON,' : ''}${gqlFilter ? '$filter: JSON,' : ''}${format ? '$format: Format' : ''}) {`;\n  }\n  let dataTypeLine = `${type} (accessibility: ${accessibility}, offset: ${offset}, first: ${size}, format: $format) {`;\n  if (gqlFilter || sort || format) {\n    dataTypeLine = `${type} (accessibility: ${accessibility}, offset: ${offset}, first: ${size}, ${format ? 'format: $format, ' : ''}, ${sort ? 'sort: $sort, ' : ''}${gqlFilter ? 'filter: $filter,' : ''}) {`;\n  }\n  let typeAggsLine = `${type} accessibility: ${accessibility} {`;\n  if (gqlFilter) {\n    typeAggsLine = `${type} (filter: $filter, accessibility: ${accessibility}) {`;\n  }\n  const processedFields = fields.map((field) => rawDataQueryStrForEachField(field));\n  const query = `${queryLine}\n    ${dataTypeLine}\n      ${processedFields.join('\\n')}\n    }\n    _aggregation {\n      ${typeAggsLine}\n        _totalCount\n      }\n    }\n  }`;\n  const queryBody = { query };\n  queryBody.variables = {};\n  if (format) queryBody.variables.format = format;\n  if (gqlFilter) queryBody.variables.filter = gqlFilter;\n  if (sort) queryBody.variables.sort = sort;\n  return fetch(`${path}${graphqlEndpoint}`, {\n    method: 'POST',\n    headers: csrfToken ? { ...headers, 'x-csrf-token': csrfToken } : headers,\n    body: JSON.stringify(queryBody),\n  }).then((response) => response.json())\n    .catch((err) => {\n      throw new Error(`Error during queryGuppyForRawDataAndTotalCounts ${err}`);\n    });\n};\n\nexport const getGQLFilter = (filterObj) => {\n  const facetsList = [];\n  Object.keys(filterObj).forEach((field) => {\n    const filterValues = filterObj[field];\n    const fieldSplitted = field.split('.');\n    const fieldName = fieldSplitted[fieldSplitted.length - 1];\n    // The combine mode defaults to OR when not set.\n    const combineMode = filterValues.__combineMode ? filterValues.__combineMode : 'OR';\n\n    const hasSelectedValues = filterValues.selectedValues && filterValues.selectedValues.length > 0;\n    const hasRangeFilter = typeof filterValues.lowerBound !== 'undefined' && typeof filterValues.upperBound !== 'undefined';\n\n    let facetsPiece = {};\n    if (hasSelectedValues && combineMode === 'OR') {\n      facetsPiece = {\n        IN: {\n          [fieldName]: filterValues.selectedValues,\n        },\n      };\n    } else if (hasSelectedValues && combineMode === 'AND') {\n      facetsPiece = { AND: [] };\n      for (let i = 0; i < filterValues.selectedValues.length; i += 1) {\n        facetsPiece.AND.push({\n          IN: {\n            [fieldName]: [filterValues.selectedValues[i]],\n          },\n        });\n      }\n    } else if (hasRangeFilter) {\n      facetsPiece = {\n        AND: [\n          { '>=': { [fieldName]: filterValues.lowerBound } },\n          { '<=': { [fieldName]: filterValues.upperBound } },\n        ],\n      };\n    } else if (filterValues.__combineMode && !hasSelectedValues && !hasRangeFilter) {\n      // This filter only has a combine setting so far. We can ignore it.\n      return;\n    } else if (hasSelectedValues) {\n      // filter has selected values but we don't know how to process it\n      // eslint-disable-next-line no-console\n      console.error(filterValues);\n      throw new Error('Invalid filter object');\n    }\n    if (fieldSplitted.length > 1) { // nested field\n      fieldSplitted.pop();\n      facetsPiece = {\n        nested: {\n          path: fieldSplitted.join('.'), // parent path\n          ...facetsPiece,\n        },\n      };\n    }\n    facetsList.push(facetsPiece);\n  });\n  const gqlFilter = {\n    AND: facetsList,\n  };\n  return gqlFilter;\n};\n\n// eslint-disable-next-line max-len\nexport const askGuppyAboutArrayTypes = (path) => queryGuppyForStatus(path).then((res) => res.indices);\n\nexport const askGuppyForAggregationData = (\n  path,\n  type,\n  regularAggFields,\n  asTextAggFields,\n  filter,\n  accessibility,\n  csrfToken = '',\n) => {\n  const gqlFilter = getGQLFilter(filter);\n  return queryGuppyForAggs(path, type, regularAggFields, asTextAggFields, gqlFilter, accessibility, csrfToken);\n};\n\nexport const askGuppyForSubAggregationData = (\n  path,\n  type,\n  mainField,\n  numericAggAsText,\n  termsNestedFields,\n  missedNestedFields,\n  filter,\n  accessibility,\n  csrfToken,\n) => {\n  const gqlFilter = getGQLFilter(filter);\n  return queryGuppyForSubAgg(\n    path,\n    type,\n    mainField,\n    termsNestedFields,\n    missedNestedFields,\n    gqlFilter,\n    accessibility,\n    numericAggAsText,\n    csrfToken,\n  );\n};\n\nexport const askGuppyForRawData = (\n  path,\n  type,\n  fields,\n  filter,\n  sort,\n  format,\n  offset = 0,\n  size = 20,\n  accessibility = 'all',\n  csrfToken = '',\n) => {\n  const gqlFilter = getGQLFilter(filter);\n  return queryGuppyForRawDataAndTotalCounts(\n    path,\n    type,\n    fields,\n    gqlFilter,\n    sort,\n    format,\n    offset,\n    size,\n    accessibility,\n    csrfToken,\n  );\n};\n\nexport const getAllFieldsFromFilterConfigs = (filterTabConfigs) => filterTabConfigs.reduce((acc, cur) => {\n  Object.keys(cur)\n    .filter((key) => key === 'fields' || key === 'asTextAggFields')\n    .forEach((key) => { acc[key] = acc[key].concat(cur[key], []); });\n  return acc;\n}, { fields: [], asTextAggFields: [] });\n\n/**\n * Download all data from guppy using fields, filter, and sort args.\n * If total count is less than 10000 this will use normal graphql endpoint\n * If greater than 10000, use /download endpoint\n */\nexport const downloadDataFromGuppy = (\n  path,\n  type,\n  totalCount,\n  {\n    fields,\n    filter,\n    sort,\n    accessibility,\n    format,\n  },\n  csrfToken = '',\n) => {\n  const SCROLL_SIZE = 10000;\n  const JSON_FORMAT = (format === 'json' || format === undefined);\n  if (totalCount > SCROLL_SIZE) {\n    const queryBody = { type };\n    if (fields) queryBody.fields = fields;\n    if (filter) queryBody.filter = getGQLFilter(filter);\n    if (sort) queryBody.sort = sort;\n    if (typeof accessibility !== 'undefined') queryBody.accessibility = accessibility;\n    return fetch(`${path}${downloadEndpoint}`, {\n      method: 'POST',\n      headers: csrfToken ? { ...headers, 'x-csrf-token': csrfToken } : headers,\n      body: JSON.stringify(queryBody),\n    })\n      .then((r) => r.json())\n      .then((res) => (JSON_FORMAT ? res : jsonToFormat(res, format)));\n  }\n  return askGuppyForRawData(path, type, fields, filter, sort, format, 0, totalCount, accessibility, csrfToken)\n    .then((res) => {\n      if (res && res.data && res.data[type]) {\n        return JSON_FORMAT ? res.data[type] : jsonToFormat(res.data[type], format);\n      }\n      throw Error('Error downloading data from Guppy');\n    });\n};\n\nexport const askGuppyForTotalCounts = (\n  path,\n  type,\n  filter,\n  accessibility = 'all',\n  csrfToken = '',\n) => {\n  const gqlFilter = getGQLFilter(filter);\n  const queryLine = `query ${gqlFilter ? '($filter: JSON)' : ''}{`;\n  const typeAggsLine = `${type} ${gqlFilter ? '(filter: $filter, ' : '('} accessibility: ${accessibility}) {`;\n  const query = `${queryLine}\n    _aggregation {\n      ${typeAggsLine}\n        _totalCount\n      }\n    }\n  }`;\n  const queryBody = { query };\n  queryBody.variables = {};\n  if (gqlFilter) queryBody.variables.filter = gqlFilter;\n\n  return fetch(`${path}${graphqlEndpoint}`, {\n    method: 'POST',\n    headers: csrfToken ? { ...headers, 'x-csrf-token': csrfToken } : headers,\n    body: JSON.stringify(queryBody),\n  }).then((response) => response.json())\n    .then((response) => {\n      if (response.errors) {\n        throw new Error(`Error during download ${response.errors}`);\n      }\n      return response.data._aggregation[type]._totalCount;\n    })\n    .catch((err) => {\n      throw new Error(`Error during download ${err}`);\n    });\n};\n\nexport const getAllFieldsFromGuppy = (\n  path,\n  type,\n  csrfToken = '',\n) => {\n  const query = `{\n    _mapping {\n      ${type}\n    }\n  }`;\n  const queryBody = { query };\n  return fetch(`${path}${graphqlEndpoint}`, {\n    method: 'POST',\n    headers: csrfToken ? { ...headers, 'x-csrf-token': csrfToken } : headers,\n    body: JSON.stringify(queryBody),\n  }).then((response) => response.json())\n    .then((response) => response.data._mapping[type])\n    .catch((err) => {\n      throw new Error(`Error when getting fields from guppy: ${err}`);\n    });\n};\n\nexport const getAccessibleResources = async (\n  path,\n  type,\n  accessibleFieldCheckList,\n  csrfToken = '',\n) => {\n  const accessiblePromiseList = [];\n  const unaccessiblePromiseList = [];\n  accessibleFieldCheckList.forEach((accessibleField) => {\n    const fetchRequestPromise = (accessible) => {\n      const query = `query {\n        _aggregation {\n          ${type} (accessibility: ${accessible ? 'accessible' : 'unaccessible'}) {\n            ${accessibleField} {\n              histogram {\n                key\n                count\n              }\n            }\n          }\n        }\n      }`;\n      const queryBody = { query };\n\n      return fetch(`${path}${graphqlEndpoint}`, {\n        method: 'POST',\n        headers: csrfToken ? { ...headers, 'x-csrf-token': csrfToken } : headers,\n        body: JSON.stringify(queryBody),\n      })\n        .then((response) => response.json())\n        .then(\n          (response) => ({\n            field: accessibleField,\n            list: (response.data._aggregation[type][accessibleField]\n              .histogram.map((item) => item.key)),\n          }),\n        )\n        .catch((err) => {\n          throw new Error(`Error when getting fields from guppy: ${err}`);\n        });\n    };\n    accessiblePromiseList.push(fetchRequestPromise(true));\n    unaccessiblePromiseList.push(fetchRequestPromise(false));\n  });\n\n  const accessibleFieldObject = {};\n  const accessibleFieldResult = await Promise.all(accessiblePromiseList);\n  accessibleFieldResult.forEach((res) => {\n    accessibleFieldObject[res.field] = res.list;\n  });\n  const unaccessibleFieldObject = {};\n  const unaccessibleFieldResult = await Promise.all(unaccessiblePromiseList);\n  unaccessibleFieldResult.forEach((res) => {\n    unaccessibleFieldObject[res.field] = res.list;\n  });\n  return { accessibleFieldObject, unaccessibleFieldObject };\n};\n","export const filterConfig = {\n  tabs: [{\n    title: 'Project',\n    fields: [\n      'project',\n      'study',\n    ],\n    asTextAggFields: [\n      'consortium_id',\n    ],\n  },\n  {\n    title: 'Subject',\n    fields: [\n      'race',\n      'ethnicity',\n      'gender',\n      'vital_status',\n    ],\n  },\n  {\n    title: 'File',\n    fields: [\n      'file_count',\n      'file_type',\n      'file_format',\n    ],\n  }],\n};\n\nexport const tableConfig = [\n  { field: 'project', name: 'Project' },\n  { field: 'study', name: 'Study' },\n  { field: 'race', name: 'Race' },\n  { field: 'ethnicity', name: 'Ethnicity' },\n  { field: 'gender', name: 'Gender' },\n  { field: 'vital_status', name: 'Vital Status' },\n  { field: 'whatever_lab_result_value', name: 'Lab Result Value' },\n  { field: 'file_count', name: 'File Count' },\n  { field: 'file_type', name: 'File Type' },\n  { field: 'file_format', name: 'File Format' },\n];\n\nexport const guppyConfig = {\n  path: 'http://localhost:3000',\n  type: 'subject',\n  fileType: 'file',\n  tierAccessLimit: 20,\n};\n\nexport const fieldMapping = [\n  {\n    field: 'project',\n    name: 'Project Name',\n  },\n];\n","\n      import API from \"!../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n      import domAPI from \"!../node_modules/style-loader/dist/runtime/styleDomAPI.js\";\n      import insertFn from \"!../node_modules/style-loader/dist/runtime/insertBySelector.js\";\n      import setAttributes from \"!../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\";\n      import insertStyleElement from \"!../node_modules/style-loader/dist/runtime/insertStyleElement.js\";\n      import styleTagTransformFn from \"!../node_modules/style-loader/dist/runtime/styleTagTransform.js\";\n      import content, * as namedExport from \"!!../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./guppyWrapper.css\";\n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = styleTagTransformFn;\noptions.setAttributes = setAttributes;\n\n      options.insert = insertFn.bind(null, \"head\");\n    \noptions.domAPI = domAPI;\noptions.insertStyleElement = insertStyleElement;\n\nvar update = API(content, options);\n\n\nif (module.hot) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n  var p;\n  for (p in a) {\n    if (isNamedExport && p === \"default\") {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n  for (p in b) {\n    if (isNamedExport && p === \"default\") {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    if (!a[p]) {\n      return false;\n    }\n  }\n  return true;\n};\n    var isNamedExport = !content.locals;\n    var oldLocals = isNamedExport ? namedExport : content.locals;\n\n    module.hot.accept(\n      \"!!../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./guppyWrapper.css\",\n      function () {\n        if (!isEqualLocals(oldLocals, isNamedExport ? namedExport : content.locals, isNamedExport)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = isNamedExport ? namedExport : content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\n\nexport * from \"!!../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[5].use[1]!./guppyWrapper.css\";\n       export default content && content.locals ? content.locals : undefined;\n"],"names":[],"sourceRoot":""}