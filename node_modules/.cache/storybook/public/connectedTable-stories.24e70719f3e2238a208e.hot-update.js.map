{"version":3,"file":"connectedTable-stories.24e70719f3e2238a208e.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AAQA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;AChZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://anagine/./src/components/GuppyWrapper/index.jsx","webpack://anagine/"],"sourcesContent":["/* eslint-disable react/jsx-fragments */\n/* eslint react/forbid-prop-types: 0 */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  askGuppyForRawData,\n  downloadDataFromGuppy,\n  askGuppyForTotalCounts,\n  getAllFieldsFromGuppy,\n  getAccessibleResources,\n  askGuppyForSubAggregationData,\n} from '../Utils/queries';\nimport { ENUM_ACCESSIBILITY, FILE_FORMATS } from '../Utils/const';\nimport { mergeFilters } from '../Utils/filters';\n\n/**\n * Wrapper that connects to Guppy server,\n * and pass filter, aggs, and data to children components\n * Input props:\n *   - filterConfig: configuration for ConnectedFilter component\n *   - guppyConfig: Guppy server config\n *   - onFilterChange: callback that takes filter as argument, will be\n * called every time filter changes\n *   - onReceiveNewAggsData: callback that takes aggregation results\n * as argument, will be called every time aggregation results updated\n *\n * This wrapper will pass following data (filters, aggs, configs) to children components via prop:\n *   - aggsData: the aggregation results, format:\n *         {\n *             // for text aggregation\n *            [field]: { histogram: [{key: 'v1', count: 42}, {key: 'v2', count: 19}, ...] },\n *             // for numeric aggregation\n *            [field]: { histogram: [{key: [1, 83], count: 100}] },\n *            ...\n *         }\n *   - filter: the filters, format:\n *         {\n *            [field]: { selectedValues: ['v1', 'v2', ...] },  // for text filter\n *            [field]: { upperBound: 1, lowerBound: 83 },  // for range filter\n *            ...\n *         }\n *   - filterConfig: configuration for ConnectedFilter component\n *   - rawData: raw data records filtered (with offset, size, and sort applied)\n *   - totalCount: total count of raw data records\n *\n */\nclass GuppyWrapper extends React.Component {\n  constructor(props) {\n    super(props);\n    let initialFilter = this.props.adminAppliedPreFilters;\n    if (Object.keys(this.props.initialFilterFromURL).length > 0) {\n      initialFilter = mergeFilters(\n        this.props.initialFilterFromURL,\n        this.props.adminAppliedPreFilters,\n      );\n    }\n\n    // to avoid asynchronizations, we store another filter as private var\n    this.filter = { ...initialFilter };\n    this.adminPreFiltersFrozen = JSON.stringify(this.props.adminAppliedPreFilters).slice();\n    this.state = {\n      gettingDataFromGuppy: false,\n      aggsData: {},\n      filter: { ...initialFilter },\n      rawData: [],\n      totalCount: 0,\n      allRegularAggFields: [],\n      allAsTextAggFields: [],\n      rawDataFields: [],\n      accessibleFieldObject: undefined,\n      unaccessibleFieldObject: undefined,\n      accessibility: ENUM_ACCESSIBILITY.ALL,\n      adminAppliedPreFilters: { ...this.props.adminAppliedPreFilters },\n      userFilterFromURL: { ...this.props.initialFilterFromURL },\n    };\n  }\n\n  componentDidMount() {\n    getAllFieldsFromGuppy(\n      this.props.guppyConfig.path,\n      this.props.guppyConfig.type,\n      this.props.csrfToken,\n    ).then((fields) => {\n      const rawDataFields = (this.props.rawDataFields && this.props.rawDataFields.length > 0)\n        ? this.props.rawDataFields : fields;\n      this.setState({\n        allRegularAggFields: fields,\n        rawDataFields,\n      }, () => {\n        this.getDataFromGuppy(this.state.rawDataFields, undefined, true);\n      });\n    });\n    if (typeof this.props.accessibleFieldCheckList !== 'undefined') {\n      getAccessibleResources(\n        this.props.guppyConfig.path,\n        this.props.guppyConfig.type,\n        this.props.accessibleFieldCheckList,\n        this.props.csrfToken,\n      ).then(({ accessibleFieldObject, unaccessibleFieldObject }) => {\n        this.setState({\n          accessibleFieldObject,\n          unaccessibleFieldObject,\n        });\n      });\n    }\n  }\n\n  handleReceiveNewAggsData(aggsData) {\n    if (this.props.onReceiveNewAggsData) {\n      this.props.onReceiveNewAggsData(aggsData, this.filter);\n    }\n    this.setState({ aggsData });\n  }\n\n  handleFilterChange(userFilterFromUserInput, accessibility) {\n    let userFilter = userFilterFromUserInput;\n\n    // Apply user filters from URL on page load. Empty out state to avoid reapplying used filters.\n    if (Object.keys(userFilter).length === 0\n      && Object.keys(this.state.userFilterFromURL).length > 0) {\n      userFilter = JSON.parse(JSON.stringify(this.state.userFilterFromURL));\n      this.setState({ userFilterFromURL: {} });\n    }\n\n    this.setState({ adminAppliedPreFilters: JSON.parse(this.adminPreFiltersFrozen) });\n    let filter = { ...userFilter };\n    if (Object.keys(this.state.adminAppliedPreFilters).length > 0) {\n      filter = mergeFilters(userFilter, this.state.adminAppliedPreFilters);\n    }\n    if (this.props.onFilterChange) {\n      this.props.onFilterChange(filter);\n    }\n    this.filter = filter;\n    this.setState({\n      filter,\n      accessibility,\n    }, () => {\n      this.getDataFromGuppy(this.state.rawDataFields, undefined, true);\n    });\n  }\n\n  /**\n   * Fetch data from Guppy server.\n   * This function will update this.state.rawData and this.state.totalCount\n   */\n  handleFetchAndUpdateRawData({ offset = 0, size = 20, sort = [] }) {\n    return this.getDataFromGuppy(this.state.rawDataFields, sort, true, offset, size);\n  }\n\n  /**\n   * Download all data from Guppy server and return raw data\n   * This function uses current filter argument\n   */\n  handleDownloadRawData({ sort, format }) {\n    // error handling for misconfigured format types\n    if (format && !(format.toUpperCase() in FILE_FORMATS)) {\n      // eslint-disable-next-line no-console\n      console.error(`Invalid value ${format} found for arg format!`);\n    }\n    return downloadDataFromGuppy(\n      this.props.guppyConfig.path,\n      this.props.guppyConfig.type,\n      this.state.totalCount,\n      {\n        fields: this.state.rawDataFields,\n        sort: sort || [],\n        filter: this.state.filter,\n        accessibility: this.state.accessibility,\n        format,\n      },\n      this.props.csrfToken,\n    );\n  }\n\n  /**\n   * Download all data from Guppy server and return raw data\n   * For only given fields\n   * This function uses current filter argument\n   */\n  handleDownloadRawDataByFields({ fields, sort = [] }) {\n    let targetFields = fields;\n    if (typeof fields === 'undefined') {\n      targetFields = this.state.rawDataFields;\n    }\n    return downloadDataFromGuppy(\n      this.props.guppyConfig.path,\n      this.props.guppyConfig.type,\n      this.state.totalCount,\n      {\n        fields: targetFields,\n        sort,\n        filter: this.state.filter,\n        accessibility: this.state.accessibility,\n      },\n      this.props.csrfToken,\n    );\n  }\n\n  /**\n   * Get total count from other es type, with filter\n   * @param {string} type\n   * @param {object} filter\n   */\n  handleAskGuppyForTotalCounts(type, filter) {\n    return askGuppyForTotalCounts(\n      this.props.guppyConfig.path,\n      type,\n      filter,\n      this.state.accessibility,\n      this.props.csrfToken,\n    );\n  }\n\n  /**\n   * Get raw data from other es type, with filter\n   * @param {string} type\n   * @param {object} filter\n   * @param {string[]} fields\n   */\n  handleDownloadRawDataByTypeAndFilter(type, filter, fields) {\n    return askGuppyForTotalCounts(\n      this.props.guppyConfig.path,\n      type,\n      filter,\n      this.state.accessibility,\n      this.props.csrfToken,\n    )\n      .then((count) => downloadDataFromGuppy(\n        this.props.guppyConfig.path,\n        type,\n        count,\n        {\n          fields,\n          filter,\n        },\n        this.props.csrfToken,\n      ));\n  }\n\n  handleAccessLevelUpdate(accessLevel) {\n    this.setState({ accessibility: accessLevel });\n  }\n\n  /**\n   * This function get data with current filter (if any),\n   * and update this.state.rawData and this.state.totalCount\n   * @param {string[]} fields\n   * @param {object} sort\n   * @param {bool} updateDataWhenReceive\n   * @param {number} offset\n   * @param {number} size\n   */\n  getDataFromGuppy(fields, sort, updateDataWhenReceive, offset, size) {\n    this.setState({ gettingDataFromGuppy: true });\n    if (!fields || fields.length === 0) {\n      this.setState({ gettingDataFromGuppy: false });\n      return Promise.resolve({ data: [], totalCount: 0 });\n    }\n\n    // sub aggregations -- for DAT\n    if (this.props.guppyConfig.mainField) {\n      const numericAggregation = this.props.guppyConfig.mainFieldIsNumeric;\n      return askGuppyForSubAggregationData(\n        this.props.guppyConfig.path,\n        this.props.guppyConfig.type,\n        this.props.guppyConfig.mainField,\n        numericAggregation,\n        this.props.guppyConfig.aggFields,\n        [],\n        this.filter,\n        this.state.accessibility,\n        this.props.csrfToken,\n      ).then((res) => {\n        if (!res || !res.data) {\n          throw new Error(`Error getting raw ${this.props.guppyConfig.type} data from Guppy server ${this.props.guppyConfig.path}.`);\n        }\n        const data = res.data._aggregation[this.props.guppyConfig.type];\n        const field = numericAggregation ? 'asTextHistogram' : 'histogram';\n        const parsedData = data[this.props.guppyConfig.mainField][field];\n        if (updateDataWhenReceive) {\n          this.setState({\n            rawData: parsedData,\n          });\n        }\n        this.setState({ gettingDataFromGuppy: false });\n        return {\n          data: res.data,\n        };\n      });\n    }\n\n    // non-nested aggregation\n    return askGuppyForRawData(\n      this.props.guppyConfig.path,\n      this.props.guppyConfig.type,\n      fields,\n      this.filter,\n      sort,\n      undefined,\n      offset,\n      size,\n      this.state.accessibility,\n      this.props.csrfToken,\n    ).then((res) => {\n      if (!res || !res.data) {\n        throw new Error(`Error getting raw ${this.props.guppyConfig.type} data from Guppy server ${this.props.guppyConfig.path}.`);\n      }\n      const parsedData = res.data[this.props.guppyConfig.type];\n      const totalCount = res.data._aggregation[this.props.guppyConfig.type]._totalCount;\n      if (updateDataWhenReceive) {\n        this.setState({\n          rawData: parsedData,\n          totalCount,\n        });\n      }\n      this.setState({ gettingDataFromGuppy: false });\n      return {\n        data: parsedData,\n        totalCount,\n      };\n    });\n  }\n\n  render() {\n    return (\n      <>\n        {\n          React.Children.map(this.props.children, (child) => React.cloneElement(child, {\n            // pass data to children\n            aggsData: this.state.aggsData,\n            aggsDataIsLoading: this.state.gettingDataFromGuppy,\n            filter: this.state.filter,\n            filterConfig: this.props.filterConfig,\n            rawData: this.state.rawData, // raw data (with current filter applied)\n            totalCount: this.state.totalCount, // total count of raw data (current filter applied)\n            fetchAndUpdateRawData: this.handleFetchAndUpdateRawData.bind(this),\n            downloadRawData: this.handleDownloadRawData.bind(this),\n            downloadRawDataByFields: this.handleDownloadRawDataByFields.bind(this),\n            allRegularAggFields: this.state.allRegularAggFields,\n            allAsTextAggFields: this.state.allAsTextAggFields,\n            accessibleFieldObject: this.state.accessibleFieldObject,\n            unaccessibleFieldObject: this.state.unaccessibleFieldObject,\n\n            // a callback function which return total counts for any type, with any filter\n            getTotalCountsByTypeAndFilter: this.handleAskGuppyForTotalCounts.bind(this),\n            downloadRawDataByTypeAndFilter: this.handleDownloadRawDataByTypeAndFilter.bind(this),\n\n            // below are just for ConnectedFilter component\n            onReceiveNewAggsData: this.handleReceiveNewAggsData.bind(this),\n            onFilterChange: this.handleFilterChange.bind(this),\n            guppyConfig: this.props.guppyConfig,\n            onUpdateAccessLevel: this.handleAccessLevelUpdate.bind(this),\n            adminAppliedPreFilters: this.props.adminAppliedPreFilters,\n            accessibleFieldCheckList: this.props.accessibleFieldCheckList,\n            csrfToken: this.props.csrfToken,\n          }))\n        }\n      </>\n    );\n  }\n}\n\nGuppyWrapper.propTypes = {\n  guppyConfig: PropTypes.shape({\n    path: PropTypes.string,\n    type: PropTypes.string,\n    mainField: PropTypes.string,\n    mainFieldIsNumeric: PropTypes.bool,\n    aggFields: PropTypes.array,\n  }).isRequired,\n  children: PropTypes.oneOfType([\n    PropTypes.arrayOf(PropTypes.node),\n    PropTypes.node,\n  ]).isRequired,\n  filterConfig: PropTypes.shape({\n    tabs: PropTypes.arrayOf(PropTypes.shape({\n      title: PropTypes.string,\n      fields: PropTypes.arrayOf(PropTypes.string),\n      searchFields: PropTypes.arrayOf(PropTypes.string),\n    })),\n  }).isRequired,\n  rawDataFields: PropTypes.arrayOf(PropTypes.string),\n  onReceiveNewAggsData: PropTypes.func,\n  onFilterChange: PropTypes.func,\n  accessibleFieldCheckList: PropTypes.arrayOf(PropTypes.string),\n  adminAppliedPreFilters: PropTypes.object,\n  initialFilterFromURL: PropTypes.object,\n  csrfToken: PropTypes.string,\n};\n\nGuppyWrapper.defaultProps = {\n  onReceiveNewAggsData: () => {},\n  onFilterChange: () => {},\n  rawDataFields: [],\n  accessibleFieldCheckList: undefined,\n  adminAppliedPreFilters: {},\n  initialFilterFromURL: {},\n  csrfToken: '',\n};\n\nexport default GuppyWrapper;\n"],"names":[],"sourceRoot":""}